# --------------------------------------------------------------------------------------------------
# <auto-generated>
#     This code was generated by a tool.
#     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
#     Template ID: 54
# </auto-generated>
# --------------------------------------------------------------------------------------------------

from typing import List, Union, Optional, TYPE_CHECKING
from autoscript_core.serialization import StructureBase
from autoscript_core.common import DataType, DataTypeDefinition

if TYPE_CHECKING:
    import autoscript_sdb_microscope_client.structures as structures


class Point(StructureBase):
    """
    The structure representing a 2D point.
    
    :param x: The X coordinate of a point.
    
    :param y: The Y coordinate of a point.
    """
    def __init__(self, x: 'float' = 0.0, y: 'float' = 0.0):
        super(Point, self).__init__("Point")

        self._init_item(1, DataType.DOUBLE, x, False)
        self._init_item(2, DataType.DOUBLE, y, False)

    def _has_x(self):
        return self._has_item(1)

    @property
    def x(self) -> 'float':
        """
        The X coordinate of a point.
        """
        return self._get_item(1)

    @x.setter
    def x(self, value: 'float'):
        """
        The X coordinate of a point.
        """
        self._set_item(1, value)

    def _has_y(self):
        return self._has_item(2)

    @property
    def y(self) -> 'float':
        """
        The Y coordinate of a point.
        """
        return self._get_item(2)

    @y.setter
    def y(self, value: 'float'):
        """
        The Y coordinate of a point.
        """
        self._set_item(2, value)


class Rectangle(StructureBase):
    """
    The structure representing a rectangular shape.
    
    :param left: The left side of a rectangle.
    
    :param top: The top side of a rectangle.
    
    :param width: The width of a rectangle.
    
    :param height: The height of a rectangle.
    """
    def __init__(self, left: 'float' = 0.0, top: 'float' = 0.0, width: 'float' = 0.0, height: 'float' = 0.0):
        super(Rectangle, self).__init__("Rectangle")

        self._init_item(1, DataType.DOUBLE, left, False)
        self._init_item(2, DataType.DOUBLE, top, False)
        self._init_item(3, DataType.DOUBLE, width, False)
        self._init_item(4, DataType.DOUBLE, height, False)

    def _has_left(self):
        return self._has_item(1)

    @property
    def left(self) -> 'float':
        """
        The left side of a rectangle.
        """
        return self._get_item(1)

    @left.setter
    def left(self, value: 'float'):
        """
        The left side of a rectangle.
        """
        self._set_item(1, value)

    def _has_top(self):
        return self._has_item(2)

    @property
    def top(self) -> 'float':
        """
        The top side of a rectangle.
        """
        return self._get_item(2)

    @top.setter
    def top(self, value: 'float'):
        """
        The top side of a rectangle.
        """
        self._set_item(2, value)

    def _has_width(self):
        return self._has_item(3)

    @property
    def width(self) -> 'float':
        """
        The width of a rectangle.
        """
        return self._get_item(3)

    @width.setter
    def width(self, value: 'float'):
        """
        The width of a rectangle.
        """
        self._set_item(3, value)

    def _has_height(self):
        return self._has_item(4)

    @property
    def height(self) -> 'float':
        """
        The height of a rectangle.
        """
        return self._get_item(4)

    @height.setter
    def height(self, value: 'float'):
        """
        The height of a rectangle.
        """
        self._set_item(4, value)


class Limits(StructureBase):
    """
    The structure representing limits of a scalar quantity.
    
    :param min: Minimal value.
    
    :param max: Maximal value.
    """
    def __init__(self, min: 'float' = 0.0, max: 'float' = 0.0):
        super(Limits, self).__init__("Limits")

        self._init_item(1, DataType.DOUBLE, min, False)
        self._init_item(2, DataType.DOUBLE, max, False)

    def _has_min(self):
        return self._has_item(1)

    @property
    def min(self) -> 'float':
        """
        Minimal value.
        """
        return self._get_item(1)

    @min.setter
    def min(self, value: 'float'):
        """
        Minimal value.
        """
        self._set_item(1, value)

    def _has_max(self):
        return self._has_item(2)

    @property
    def max(self) -> 'float':
        """
        Maximal value.
        """
        return self._get_item(2)

    @max.setter
    def max(self, value: 'float'):
        """
        Maximal value.
        """
        self._set_item(2, value)


class Limits2d(StructureBase):
    """
    The structure representing limits of a 2D quantity.
    
    :param limits_x: Limits in X direction.
    
    :param limits_y: Limits in Y direction.
    """
    def __init__(self, limits_x: 'structures.Limits' = None, limits_y: 'structures.Limits' = None):
        super(Limits2d, self).__init__("Limits2d")

        self._init_item(1, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Limits"), limits_x, False)
        self._init_item(2, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Limits"), limits_y, False)

    def _has_limits_x(self):
        return self._has_item(1)

    @property
    def limits_x(self) -> 'structures.Limits':
        """
        Limits in X direction.
        """
        return self._get_item(1)

    @limits_x.setter
    def limits_x(self, value: 'structures.Limits'):
        """
        Limits in X direction.
        """
        self._set_item(1, value)

    def _has_limits_y(self):
        return self._has_item(2)

    @property
    def limits_y(self) -> 'structures.Limits':
        """
        Limits in Y direction.
        """
        return self._get_item(2)

    @limits_y.setter
    def limits_y(self, value: 'structures.Limits'):
        """
        Limits in Y direction.
        """
        self._set_item(2, value)


class GrabFrameSettings(StructureBase):
    """
    The structure representing additional settings for a grab frame action.
    
    :param resolution: Image size in pixels. You can use ScanningResolution enumeration to access standard resolution presets.
    
    :param dwell_time: The time the beam scans a single pixel.
    
    :param bit_depth: The number of bits representing one pixel. It can be either 8 or 16 bits for grayscale images or 24 for RGB images.
    
    :param reduced_area: The rectangular area which should be scanned specified in the reduced area coordinate system. In this system point [0,0] corresponds to the upper left image corner and point [1, 1] to the lower right image corner.
    
    :param line_integration: If the number is > 1, each line scan is repeated several times (from 2 to 255) before proceeding to the next line. Signal data collected from these passes are integrated and shown as an actual image line. The default is 1.
    
    :param scan_interlacing: If the number is > 1, scanning splits an imaging area into blocks defined by the number of lines (from 2 to 8). In the first instance, the first line of each block is scanned, then the second one, etc. This imaging method significantly reduces sample charging. The default is 1.
    
    :param preview_resolution: Preview image resolution. This property is only considered for the grab_frame_to_disk() function.
    
    :param frame_integration: If the number is > 1, integration filter is switched on during image acquisition with specified number of frames.
    
    :param drift_correction: Enables to correct image drifting when integration filter is active. Requires frame_inegration parameter be specified and > 1.
    """
    def __init__(self, resolution: 'str' = None, dwell_time: 'float' = None, bit_depth: 'int' = None, reduced_area: 'structures.Rectangle' = None, line_integration: 'int' = None, scan_interlacing: 'int' = None, preview_resolution: 'str' = None, frame_integration: 'int' = None, drift_correction: 'bool' = None):
        super(GrabFrameSettings, self).__init__("GrabFrameSettings")

        self._init_item(6, DataType.STRING, resolution, True)
        self._init_item(7, DataType.DOUBLE, dwell_time, True)
        self._init_item(1, DataType.INT32, bit_depth, True)
        self._init_item(2, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), reduced_area, True)
        self._init_item(3, DataType.INT32, line_integration, True)
        self._init_item(5, DataType.INT32, scan_interlacing, True)
        self._init_item(8, DataType.STRING, preview_resolution, True)
        self._init_item(9, DataType.INT32, frame_integration, True)
        self._init_item(10, DataType.BOOL, drift_correction, True)

    def _has_resolution(self):
        return self._has_item(6)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Image size in pixels. You can use ScanningResolution enumeration to access standard resolution presets.
        """
        return self._get_item(6)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Image size in pixels. You can use ScanningResolution enumeration to access standard resolution presets.
        """
        self._set_item(6, value)

    def _has_dwell_time(self):
        return self._has_item(7)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        The time the beam scans a single pixel.
        """
        return self._get_item(7)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        The time the beam scans a single pixel.
        """
        self._set_item(7, value)

    def _has_bit_depth(self):
        return self._has_item(1)

    @property
    def bit_depth(self) -> 'Optional[int]':
        """
        The number of bits representing one pixel. It can be either 8 or 16 bits for grayscale images or 24 for RGB images.
        """
        return self._get_item(1)

    @bit_depth.setter
    def bit_depth(self, value: 'Optional[int]'):
        """
        The number of bits representing one pixel. It can be either 8 or 16 bits for grayscale images or 24 for RGB images.
        """
        self._set_item(1, value)

    def _has_reduced_area(self):
        return self._has_item(2)

    @property
    def reduced_area(self) -> 'Optional[structures.Rectangle]':
        """
        The rectangular area which should be scanned specified in the reduced area coordinate system. In this system point [0,0] corresponds to the upper left image corner and point [1, 1] to the lower right image corner.
        """
        return self._get_item(2)

    @reduced_area.setter
    def reduced_area(self, value: 'Optional[structures.Rectangle]'):
        """
        The rectangular area which should be scanned specified in the reduced area coordinate system. In this system point [0,0] corresponds to the upper left image corner and point [1, 1] to the lower right image corner.
        """
        self._set_item(2, value)

    def _has_line_integration(self):
        return self._has_item(3)

    @property
    def line_integration(self) -> 'Optional[int]':
        """
        If the number is > 1, each line scan is repeated several times (from 2 to 255) before proceeding to the next line. Signal data collected from these passes are integrated and shown as an actual image line. The default is 1.
        """
        return self._get_item(3)

    @line_integration.setter
    def line_integration(self, value: 'Optional[int]'):
        """
        If the number is > 1, each line scan is repeated several times (from 2 to 255) before proceeding to the next line. Signal data collected from these passes are integrated and shown as an actual image line. The default is 1.
        """
        self._set_item(3, value)

    def _has_scan_interlacing(self):
        return self._has_item(5)

    @property
    def scan_interlacing(self) -> 'Optional[int]':
        """
        If the number is > 1, scanning splits an imaging area into blocks defined by the number of lines (from 2 to 8). In the first instance, the first line of each block is scanned, then the second one, etc. This imaging method significantly reduces sample charging. The default is 1.
        """
        return self._get_item(5)

    @scan_interlacing.setter
    def scan_interlacing(self, value: 'Optional[int]'):
        """
        If the number is > 1, scanning splits an imaging area into blocks defined by the number of lines (from 2 to 8). In the first instance, the first line of each block is scanned, then the second one, etc. This imaging method significantly reduces sample charging. The default is 1.
        """
        self._set_item(5, value)

    def _has_preview_resolution(self):
        return self._has_item(8)

    @property
    def preview_resolution(self) -> 'Optional[str]':
        """
        Preview image resolution. This property is only considered for the grab_frame_to_disk() function.
        """
        return self._get_item(8)

    @preview_resolution.setter
    def preview_resolution(self, value: 'Optional[str]'):
        """
        Preview image resolution. This property is only considered for the grab_frame_to_disk() function.
        """
        self._set_item(8, value)

    def _has_frame_integration(self):
        return self._has_item(9)

    @property
    def frame_integration(self) -> 'Optional[int]':
        """
        If the number is > 1, integration filter is switched on during image acquisition with specified number of frames.
        """
        return self._get_item(9)

    @frame_integration.setter
    def frame_integration(self, value: 'Optional[int]'):
        """
        If the number is > 1, integration filter is switched on during image acquisition with specified number of frames.
        """
        self._set_item(9, value)

    def _has_drift_correction(self):
        return self._has_item(10)

    @property
    def drift_correction(self) -> 'Optional[bool]':
        """
        Enables to correct image drifting when integration filter is active. Requires frame_inegration parameter be specified and > 1.
        """
        return self._get_item(10)

    @drift_correction.setter
    def drift_correction(self, value: 'Optional[bool]'):
        """
        Enables to correct image drifting when integration filter is active. Requires frame_inegration parameter be specified and > 1.
        """
        self._set_item(10, value)


class RunAutoSourceTiltSettings(StructureBase):
    """
    Settings for automatic source tilt adjustment routines.
    
    :param method: Name of the the auto source tilt algorithm variant.
    
    :param contrast: Detector contrast to be used during the routine.
    
    :param brightness: Detector brightness to be used during the routine.
    
    :param dwell_time: Dwell time to be used during the routine.
    
    :param resolution: Resolution to be used during the routine.
    """
    def __init__(self, method: 'str' = None, contrast: 'float' = None, brightness: 'float' = None, dwell_time: 'float' = None, resolution: 'str' = None):
        super(RunAutoSourceTiltSettings, self).__init__("RunAutoSourceTiltSettings")

        self._init_item(1, DataType.STRING, method, True)
        self._init_item(2, DataType.DOUBLE, contrast, True)
        self._init_item(3, DataType.DOUBLE, brightness, True)
        self._init_item(4, DataType.DOUBLE, dwell_time, True)
        self._init_item(5, DataType.STRING, resolution, True)

    def _has_method(self):
        return self._has_item(1)

    @property
    def method(self) -> 'Optional[str]':
        """
        Name of the the auto source tilt algorithm variant.
        """
        return self._get_item(1)

    @method.setter
    def method(self, value: 'Optional[str]'):
        """
        Name of the the auto source tilt algorithm variant.
        """
        self._set_item(1, value)

    def _has_contrast(self):
        return self._has_item(2)

    @property
    def contrast(self) -> 'Optional[float]':
        """
        Detector contrast to be used during the routine.
        """
        return self._get_item(2)

    @contrast.setter
    def contrast(self, value: 'Optional[float]'):
        """
        Detector contrast to be used during the routine.
        """
        self._set_item(2, value)

    def _has_brightness(self):
        return self._has_item(3)

    @property
    def brightness(self) -> 'Optional[float]':
        """
        Detector brightness to be used during the routine.
        """
        return self._get_item(3)

    @brightness.setter
    def brightness(self, value: 'Optional[float]'):
        """
        Detector brightness to be used during the routine.
        """
        self._set_item(3, value)

    def _has_dwell_time(self):
        return self._has_item(4)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        Dwell time to be used during the routine.
        """
        return self._get_item(4)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        Dwell time to be used during the routine.
        """
        self._set_item(4, value)

    def _has_resolution(self):
        return self._has_item(5)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Resolution to be used during the routine.
        """
        return self._get_item(5)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Resolution to be used during the routine.
        """
        self._set_item(5, value)


class RunAutoCbSettings(StructureBase):
    """
    Settings for automatic brightness and contrast adjustment routines.
    
    :param black_target: Grayscale level at which the black pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
    
    :param white_target: Grayscale level at which the white pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
    
    :param method: Name of the the auto contrast brightness algorithm variant.
    
    :param calibrate_detector: Whether to force detector calibration prior to running the routine. Normally, it is sufficient to calibrate the detector only once. Using this option, you can make the routine more robust in exchange for a slightly longer duration.
    
    :param dwell_time: Dwell time to be used during the routine.
    
    :param line_integration: Line integration to be used during the routine.
    
    :param max_black_clipping: Maximum percentage of black pixels which can be clipped during the routine. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
    
    :param max_white_clipping: Maximum percentage of white pixels which can be clipped during the routine. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
    
    :param number_of_frames: Number of frames to be used during the routine.
    
    :param resolution: Resolution to be used during the routine.
    
    :param brightness_target: Brightness level at which the median brightness pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
    """
    def __init__(self, black_target: 'float' = None, white_target: 'float' = None, method: 'str' = None, calibrate_detector: 'bool' = None, dwell_time: 'float' = None, line_integration: 'int' = None, max_black_clipping: 'float' = None, max_white_clipping: 'float' = None, number_of_frames: 'int' = None, resolution: 'str' = None, brightness_target: 'float' = None):
        super(RunAutoCbSettings, self).__init__("RunAutoCbSettings")

        self._init_item(1, DataType.DOUBLE, black_target, True)
        self._init_item(2, DataType.DOUBLE, white_target, True)
        self._init_item(3, DataType.STRING, method, True)
        self._init_item(4, DataType.BOOL, calibrate_detector, True)
        self._init_item(5, DataType.DOUBLE, dwell_time, True)
        self._init_item(6, DataType.INT32, line_integration, True)
        self._init_item(7, DataType.DOUBLE, max_black_clipping, True)
        self._init_item(8, DataType.DOUBLE, max_white_clipping, True)
        self._init_item(9, DataType.INT32, number_of_frames, True)
        self._init_item(10, DataType.STRING, resolution, True)
        self._init_item(11, DataType.DOUBLE, brightness_target, True)

    def _has_black_target(self):
        return self._has_item(1)

    @property
    def black_target(self) -> 'Optional[float]':
        """
        Grayscale level at which the black pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        return self._get_item(1)

    @black_target.setter
    def black_target(self, value: 'Optional[float]'):
        """
        Grayscale level at which the black pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        self._set_item(1, value)

    def _has_white_target(self):
        return self._has_item(2)

    @property
    def white_target(self) -> 'Optional[float]':
        """
        Grayscale level at which the white pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        return self._get_item(2)

    @white_target.setter
    def white_target(self, value: 'Optional[float]'):
        """
        Grayscale level at which the white pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        self._set_item(2, value)

    def _has_method(self):
        return self._has_item(3)

    @property
    def method(self) -> 'Optional[str]':
        """
        Name of the the auto contrast brightness algorithm variant.
        """
        return self._get_item(3)

    @method.setter
    def method(self, value: 'Optional[str]'):
        """
        Name of the the auto contrast brightness algorithm variant.
        """
        self._set_item(3, value)

    def _has_calibrate_detector(self):
        return self._has_item(4)

    @property
    def calibrate_detector(self) -> 'Optional[bool]':
        """
        Whether to force detector calibration prior to running the routine. Normally, it is sufficient to calibrate the detector only once. Using this option, you can make the routine more robust in exchange for a slightly longer duration.
        """
        return self._get_item(4)

    @calibrate_detector.setter
    def calibrate_detector(self, value: 'Optional[bool]'):
        """
        Whether to force detector calibration prior to running the routine. Normally, it is sufficient to calibrate the detector only once. Using this option, you can make the routine more robust in exchange for a slightly longer duration.
        """
        self._set_item(4, value)

    def _has_dwell_time(self):
        return self._has_item(5)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        Dwell time to be used during the routine.
        """
        return self._get_item(5)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        Dwell time to be used during the routine.
        """
        self._set_item(5, value)

    def _has_line_integration(self):
        return self._has_item(6)

    @property
    def line_integration(self) -> 'Optional[int]':
        """
        Line integration to be used during the routine.
        """
        return self._get_item(6)

    @line_integration.setter
    def line_integration(self, value: 'Optional[int]'):
        """
        Line integration to be used during the routine.
        """
        self._set_item(6, value)

    def _has_max_black_clipping(self):
        return self._has_item(7)

    @property
    def max_black_clipping(self) -> 'Optional[float]':
        """
        Maximum percentage of black pixels which can be clipped during the routine. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        return self._get_item(7)

    @max_black_clipping.setter
    def max_black_clipping(self, value: 'Optional[float]'):
        """
        Maximum percentage of black pixels which can be clipped during the routine. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        self._set_item(7, value)

    def _has_max_white_clipping(self):
        return self._has_item(8)

    @property
    def max_white_clipping(self) -> 'Optional[float]':
        """
        Maximum percentage of white pixels which can be clipped during the routine. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        return self._get_item(8)

    @max_white_clipping.setter
    def max_white_clipping(self, value: 'Optional[float]'):
        """
        Maximum percentage of white pixels which can be clipped during the routine. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        self._set_item(8, value)

    def _has_number_of_frames(self):
        return self._has_item(9)

    @property
    def number_of_frames(self) -> 'Optional[int]':
        """
        Number of frames to be used during the routine.
        """
        return self._get_item(9)

    @number_of_frames.setter
    def number_of_frames(self, value: 'Optional[int]'):
        """
        Number of frames to be used during the routine.
        """
        self._set_item(9, value)

    def _has_resolution(self):
        return self._has_item(10)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Resolution to be used during the routine.
        """
        return self._get_item(10)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Resolution to be used during the routine.
        """
        self._set_item(10, value)

    def _has_brightness_target(self):
        return self._has_item(11)

    @property
    def brightness_target(self) -> 'Optional[float]':
        """
        Brightness level at which the median brightness pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        return self._get_item(11)

    @brightness_target.setter
    def brightness_target(self, value: 'Optional[float]'):
        """
        Brightness level at which the median brightness pixels should be placed. The value is expected to be in the range between [0, 1] corresponding to 0% - 100%.
        """
        self._set_item(11, value)


class RunAutoFocusSettings(StructureBase):
    """
    Settings for automatic focus routines.
    
    :param method: Name of the the auto focus algorithm variant.
    
    :param dwell_time: Dwell time to be used during the routine.
    
    :param horizontal_field_width: Horizontal field width to be used during the routine.
    
    :param line_integration: Line integration to be used during the routine.
    
    :param number_of_frames: Number of frames to be used during the routine.
    
    :param reduced_area: Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
    
    :param resolution: Resolution to be used during the routine.
    
    :param working_distance_step: Initial working distance step to be used by the routine while searching for the optimal focus setting.
    
    :param display_point: The point from which reduced area will be computed. In this system point [0,0] means left-top image corner and point [1, 1] right-bottom image corner.
    """
    def __init__(self, method: 'str' = None, dwell_time: 'float' = None, horizontal_field_width: 'float' = None, line_integration: 'int' = None, number_of_frames: 'int' = None, reduced_area: 'structures.Rectangle' = None, resolution: 'str' = None, working_distance_step: 'float' = None, display_point: 'structures.Point' = None):
        super(RunAutoFocusSettings, self).__init__("RunAutoFocusSettings")

        self._init_item(1, DataType.STRING, method, True)
        self._init_item(2, DataType.DOUBLE, dwell_time, True)
        self._init_item(3, DataType.DOUBLE, horizontal_field_width, True)
        self._init_item(5, DataType.INT32, line_integration, True)
        self._init_item(6, DataType.INT32, number_of_frames, True)
        self._init_item(7, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), reduced_area, True)
        self._init_item(8, DataType.STRING, resolution, True)
        self._init_item(9, DataType.DOUBLE, working_distance_step, True)
        self._init_item(10, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), display_point, True)

    def _has_method(self):
        return self._has_item(1)

    @property
    def method(self) -> 'Optional[str]':
        """
        Name of the the auto focus algorithm variant.
        """
        return self._get_item(1)

    @method.setter
    def method(self, value: 'Optional[str]'):
        """
        Name of the the auto focus algorithm variant.
        """
        self._set_item(1, value)

    def _has_dwell_time(self):
        return self._has_item(2)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        Dwell time to be used during the routine.
        """
        return self._get_item(2)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        Dwell time to be used during the routine.
        """
        self._set_item(2, value)

    def _has_horizontal_field_width(self):
        return self._has_item(3)

    @property
    def horizontal_field_width(self) -> 'Optional[float]':
        """
        Horizontal field width to be used during the routine.
        """
        return self._get_item(3)

    @horizontal_field_width.setter
    def horizontal_field_width(self, value: 'Optional[float]'):
        """
        Horizontal field width to be used during the routine.
        """
        self._set_item(3, value)

    def _has_line_integration(self):
        return self._has_item(5)

    @property
    def line_integration(self) -> 'Optional[int]':
        """
        Line integration to be used during the routine.
        """
        return self._get_item(5)

    @line_integration.setter
    def line_integration(self, value: 'Optional[int]'):
        """
        Line integration to be used during the routine.
        """
        self._set_item(5, value)

    def _has_number_of_frames(self):
        return self._has_item(6)

    @property
    def number_of_frames(self) -> 'Optional[int]':
        """
        Number of frames to be used during the routine.
        """
        return self._get_item(6)

    @number_of_frames.setter
    def number_of_frames(self, value: 'Optional[int]'):
        """
        Number of frames to be used during the routine.
        """
        self._set_item(6, value)

    def _has_reduced_area(self):
        return self._has_item(7)

    @property
    def reduced_area(self) -> 'Optional[structures.Rectangle]':
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        return self._get_item(7)

    @reduced_area.setter
    def reduced_area(self, value: 'Optional[structures.Rectangle]'):
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        self._set_item(7, value)

    def _has_resolution(self):
        return self._has_item(8)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Resolution to be used during the routine.
        """
        return self._get_item(8)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Resolution to be used during the routine.
        """
        self._set_item(8, value)

    def _has_working_distance_step(self):
        return self._has_item(9)

    @property
    def working_distance_step(self) -> 'Optional[float]':
        """
        Initial working distance step to be used by the routine while searching for the optimal focus setting.
        """
        return self._get_item(9)

    @working_distance_step.setter
    def working_distance_step(self, value: 'Optional[float]'):
        """
        Initial working distance step to be used by the routine while searching for the optimal focus setting.
        """
        self._set_item(9, value)

    def _has_display_point(self):
        return self._has_item(10)

    @property
    def display_point(self) -> 'Optional[structures.Point]':
        """
        The point from which reduced area will be computed. In this system point [0,0] means left-top image corner and point [1, 1] right-bottom image corner.
        """
        return self._get_item(10)

    @display_point.setter
    def display_point(self, value: 'Optional[structures.Point]'):
        """
        The point from which reduced area will be computed. In this system point [0,0] means left-top image corner and point [1, 1] right-bottom image corner.
        """
        self._set_item(10, value)


class RunAutoLensAlignmentSettings(StructureBase):
    """
    Settings for automatic lens alignment adjustment routines.
    
    :param method: Name of the the auto lens alignment algorithm variant.
    
    :param dwell_time: Dwell time to be used during the routine.
    
    :param line_integration: Line integration to be used during the routine.
    
    :param modulation_type: Modulation type to be used during the routine.
    
    :param number_of_frames: Number of frames to be used during the routine.
    
    :param reduced_area: Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
    
    :param resolution: Resolution to be used during the routine.
    """
    def __init__(self, method: 'str' = None, dwell_time: 'float' = None, line_integration: 'int' = None, modulation_type: 'str' = None, number_of_frames: 'int' = None, reduced_area: 'structures.Rectangle' = None, resolution: 'str' = None):
        super(RunAutoLensAlignmentSettings, self).__init__("RunAutoLensAlignmentSettings")

        self._init_item(1, DataType.STRING, method, True)
        self._init_item(2, DataType.DOUBLE, dwell_time, True)
        self._init_item(3, DataType.INT32, line_integration, True)
        self._init_item(4, DataType.STRING, modulation_type, True)
        self._init_item(5, DataType.INT32, number_of_frames, True)
        self._init_item(6, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), reduced_area, True)
        self._init_item(7, DataType.STRING, resolution, True)

    def _has_method(self):
        return self._has_item(1)

    @property
    def method(self) -> 'Optional[str]':
        """
        Name of the the auto lens alignment algorithm variant.
        """
        return self._get_item(1)

    @method.setter
    def method(self, value: 'Optional[str]'):
        """
        Name of the the auto lens alignment algorithm variant.
        """
        self._set_item(1, value)

    def _has_dwell_time(self):
        return self._has_item(2)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        Dwell time to be used during the routine.
        """
        return self._get_item(2)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        Dwell time to be used during the routine.
        """
        self._set_item(2, value)

    def _has_line_integration(self):
        return self._has_item(3)

    @property
    def line_integration(self) -> 'Optional[int]':
        """
        Line integration to be used during the routine.
        """
        return self._get_item(3)

    @line_integration.setter
    def line_integration(self, value: 'Optional[int]'):
        """
        Line integration to be used during the routine.
        """
        self._set_item(3, value)

    def _has_modulation_type(self):
        return self._has_item(4)

    @property
    def modulation_type(self) -> 'Optional[str]':
        """
        Modulation type to be used during the routine.
        """
        return self._get_item(4)

    @modulation_type.setter
    def modulation_type(self, value: 'Optional[str]'):
        """
        Modulation type to be used during the routine.
        """
        self._set_item(4, value)

    def _has_number_of_frames(self):
        return self._has_item(5)

    @property
    def number_of_frames(self) -> 'Optional[int]':
        """
        Number of frames to be used during the routine.
        """
        return self._get_item(5)

    @number_of_frames.setter
    def number_of_frames(self, value: 'Optional[int]'):
        """
        Number of frames to be used during the routine.
        """
        self._set_item(5, value)

    def _has_reduced_area(self):
        return self._has_item(6)

    @property
    def reduced_area(self) -> 'Optional[structures.Rectangle]':
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        return self._get_item(6)

    @reduced_area.setter
    def reduced_area(self, value: 'Optional[structures.Rectangle]'):
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        self._set_item(6, value)

    def _has_resolution(self):
        return self._has_item(7)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Resolution to be used during the routine.
        """
        return self._get_item(7)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Resolution to be used during the routine.
        """
        self._set_item(7, value)


class RunAutoStigmatorCenteringSettings(StructureBase):
    """
    Settings for automatic brightness and contrast adjustment routines.
    
    :param method: Name of the the auto stigmator centering algorithm variant.
    
    :param dwell_time: Dwell time to be used during the routine.
    
    :param line_integration: Line integration to be used during the routine.
    
    :param number_of_frames: Number of frames to be used during the routine.
    
    :param reduced_area: Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
    
    :param resolution: Resolution to be used during the routine.
    """
    def __init__(self, method: 'str' = None, dwell_time: 'float' = None, line_integration: 'int' = None, number_of_frames: 'int' = None, reduced_area: 'structures.Rectangle' = None, resolution: 'str' = None):
        super(RunAutoStigmatorCenteringSettings, self).__init__("RunAutoStigmatorCenteringSettings")

        self._init_item(1, DataType.STRING, method, True)
        self._init_item(2, DataType.DOUBLE, dwell_time, True)
        self._init_item(3, DataType.INT32, line_integration, True)
        self._init_item(4, DataType.INT32, number_of_frames, True)
        self._init_item(5, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), reduced_area, True)
        self._init_item(6, DataType.STRING, resolution, True)

    def _has_method(self):
        return self._has_item(1)

    @property
    def method(self) -> 'Optional[str]':
        """
        Name of the the auto stigmator centering algorithm variant.
        """
        return self._get_item(1)

    @method.setter
    def method(self, value: 'Optional[str]'):
        """
        Name of the the auto stigmator centering algorithm variant.
        """
        self._set_item(1, value)

    def _has_dwell_time(self):
        return self._has_item(2)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        Dwell time to be used during the routine.
        """
        return self._get_item(2)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        Dwell time to be used during the routine.
        """
        self._set_item(2, value)

    def _has_line_integration(self):
        return self._has_item(3)

    @property
    def line_integration(self) -> 'Optional[int]':
        """
        Line integration to be used during the routine.
        """
        return self._get_item(3)

    @line_integration.setter
    def line_integration(self, value: 'Optional[int]'):
        """
        Line integration to be used during the routine.
        """
        self._set_item(3, value)

    def _has_number_of_frames(self):
        return self._has_item(4)

    @property
    def number_of_frames(self) -> 'Optional[int]':
        """
        Number of frames to be used during the routine.
        """
        return self._get_item(4)

    @number_of_frames.setter
    def number_of_frames(self, value: 'Optional[int]'):
        """
        Number of frames to be used during the routine.
        """
        self._set_item(4, value)

    def _has_reduced_area(self):
        return self._has_item(5)

    @property
    def reduced_area(self) -> 'Optional[structures.Rectangle]':
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        return self._get_item(5)

    @reduced_area.setter
    def reduced_area(self, value: 'Optional[structures.Rectangle]'):
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        self._set_item(5, value)

    def _has_resolution(self):
        return self._has_item(6)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Resolution to be used during the routine.
        """
        return self._get_item(6)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Resolution to be used during the routine.
        """
        self._set_item(6, value)


class RunAutoStigmatorSettings(StructureBase):
    """
    Settings for automatic stigmator adjustment routines.
    
    :param method: Name of the the auto stigmator algorithm variant.
    
    :param dwell_time: Dwell time to be used during the routine.
    
    :param horizontal_field_width: Horizontal field width to be used during the routine.
    
    :param line_integration: Line integration to be used during the routine.
    
    :param number_of_frames: Number of frames to be used during the routine.
    
    :param reduced_area: Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
    
    :param resolution: Resolution to be used during the routine.
    
    :param stigmation_step: Initial stigmation step to be used by the routine while searching for the optimal stigmator setting.
    
    :param display_point: Point in imaging view from which the reduced area position will be calculated. Point [0,0] corresponds to the upper left corner of the view, point [1, 1] to the lower right corner.
    """
    def __init__(self, method: 'str' = None, dwell_time: 'float' = None, horizontal_field_width: 'float' = None, line_integration: 'int' = None, number_of_frames: 'int' = None, reduced_area: 'structures.Rectangle' = None, resolution: 'str' = None, stigmation_step: 'float' = None, display_point: 'structures.Point' = None):
        super(RunAutoStigmatorSettings, self).__init__("RunAutoStigmatorSettings")

        self._init_item(1, DataType.STRING, method, True)
        self._init_item(2, DataType.DOUBLE, dwell_time, True)
        self._init_item(3, DataType.DOUBLE, horizontal_field_width, True)
        self._init_item(4, DataType.INT32, line_integration, True)
        self._init_item(5, DataType.INT32, number_of_frames, True)
        self._init_item(6, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), reduced_area, True)
        self._init_item(7, DataType.STRING, resolution, True)
        self._init_item(8, DataType.DOUBLE, stigmation_step, True)
        self._init_item(9, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), display_point, True)

    def _has_method(self):
        return self._has_item(1)

    @property
    def method(self) -> 'Optional[str]':
        """
        Name of the the auto stigmator algorithm variant.
        """
        return self._get_item(1)

    @method.setter
    def method(self, value: 'Optional[str]'):
        """
        Name of the the auto stigmator algorithm variant.
        """
        self._set_item(1, value)

    def _has_dwell_time(self):
        return self._has_item(2)

    @property
    def dwell_time(self) -> 'Optional[float]':
        """
        Dwell time to be used during the routine.
        """
        return self._get_item(2)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        """
        Dwell time to be used during the routine.
        """
        self._set_item(2, value)

    def _has_horizontal_field_width(self):
        return self._has_item(3)

    @property
    def horizontal_field_width(self) -> 'Optional[float]':
        """
        Horizontal field width to be used during the routine.
        """
        return self._get_item(3)

    @horizontal_field_width.setter
    def horizontal_field_width(self, value: 'Optional[float]'):
        """
        Horizontal field width to be used during the routine.
        """
        self._set_item(3, value)

    def _has_line_integration(self):
        return self._has_item(4)

    @property
    def line_integration(self) -> 'Optional[int]':
        """
        Line integration to be used during the routine.
        """
        return self._get_item(4)

    @line_integration.setter
    def line_integration(self, value: 'Optional[int]'):
        """
        Line integration to be used during the routine.
        """
        self._set_item(4, value)

    def _has_number_of_frames(self):
        return self._has_item(5)

    @property
    def number_of_frames(self) -> 'Optional[int]':
        """
        Number of frames to be used during the routine.
        """
        return self._get_item(5)

    @number_of_frames.setter
    def number_of_frames(self, value: 'Optional[int]'):
        """
        Number of frames to be used during the routine.
        """
        self._set_item(5, value)

    def _has_reduced_area(self):
        return self._has_item(6)

    @property
    def reduced_area(self) -> 'Optional[structures.Rectangle]':
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        return self._get_item(6)

    @reduced_area.setter
    def reduced_area(self, value: 'Optional[structures.Rectangle]'):
        """
        Reduced area to be used during the routine. Point [0,0] corresponds to the upper left corner of the image, point [1, 1] to the lower right corner.
        """
        self._set_item(6, value)

    def _has_resolution(self):
        return self._has_item(7)

    @property
    def resolution(self) -> 'Optional[str]':
        """
        Resolution to be used during the routine.
        """
        return self._get_item(7)

    @resolution.setter
    def resolution(self, value: 'Optional[str]'):
        """
        Resolution to be used during the routine.
        """
        self._set_item(7, value)

    def _has_stigmation_step(self):
        return self._has_item(8)

    @property
    def stigmation_step(self) -> 'Optional[float]':
        """
        Initial stigmation step to be used by the routine while searching for the optimal stigmator setting.
        """
        return self._get_item(8)

    @stigmation_step.setter
    def stigmation_step(self, value: 'Optional[float]'):
        """
        Initial stigmation step to be used by the routine while searching for the optimal stigmator setting.
        """
        self._set_item(8, value)

    def _has_display_point(self):
        return self._has_item(9)

    @property
    def display_point(self) -> 'Optional[structures.Point]':
        """
        Point in imaging view from which the reduced area position will be calculated. Point [0,0] corresponds to the upper left corner of the view, point [1, 1] to the lower right corner.
        """
        return self._get_item(9)

    @display_point.setter
    def display_point(self, value: 'Optional[structures.Point]'):
        """
        Point in imaging view from which the reduced area position will be calculated. Point [0,0] corresponds to the upper left corner of the view, point [1, 1] to the lower right corner.
        """
        self._set_item(9, value)


class CompustagePosition(StructureBase):
    """
    The structure representing a compustage position.
    
    :param x: X coordinate.
    
    :param y: Y coordinate.
    
    :param z: Z coordinate.
    
    :param a: Alpha coordinate.
    
    :param b: Beta coordinate.
    """
    def __init__(self, x: 'float' = None, y: 'float' = None, z: 'float' = None, a: 'float' = None, b: 'float' = None):
        super(CompustagePosition, self).__init__("CompustagePosition")

        self._init_item(1, DataType.DOUBLE, x, True)
        self._init_item(2, DataType.DOUBLE, y, True)
        self._init_item(3, DataType.DOUBLE, z, True)
        self._init_item(4, DataType.DOUBLE, a, True)
        self._init_item(5, DataType.DOUBLE, b, True)

    def _has_x(self):
        return self._has_item(1)

    @property
    def x(self) -> 'Optional[float]':
        """
        X coordinate.
        """
        return self._get_item(1)

    @x.setter
    def x(self, value: 'Optional[float]'):
        """
        X coordinate.
        """
        self._set_item(1, value)

    def _has_y(self):
        return self._has_item(2)

    @property
    def y(self) -> 'Optional[float]':
        """
        Y coordinate.
        """
        return self._get_item(2)

    @y.setter
    def y(self, value: 'Optional[float]'):
        """
        Y coordinate.
        """
        self._set_item(2, value)

    def _has_z(self):
        return self._has_item(3)

    @property
    def z(self) -> 'Optional[float]':
        """
        Z coordinate.
        """
        return self._get_item(3)

    @z.setter
    def z(self, value: 'Optional[float]'):
        """
        Z coordinate.
        """
        self._set_item(3, value)

    def _has_a(self):
        return self._has_item(4)

    @property
    def a(self) -> 'Optional[float]':
        """
        Alpha coordinate.
        """
        return self._get_item(4)

    @a.setter
    def a(self, value: 'Optional[float]'):
        """
        Alpha coordinate.
        """
        self._set_item(4, value)

    def _has_b(self):
        return self._has_item(5)

    @property
    def b(self) -> 'Optional[float]':
        """
        Beta coordinate.
        """
        return self._get_item(5)

    @b.setter
    def b(self, value: 'Optional[float]'):
        """
        Beta coordinate.
        """
        self._set_item(5, value)


class StagePosition(StructureBase):
    """
    The structure representing a stage position.
    
    :param x: X coordinate.
    
    :param y: Y coordinate.
    
    :param z: Z coordinate.
    
    :param r: Rotation.
    
    :param t: Tilt.
    
    :param coordinate_system: The coordinate system in which the position is specified.
    """
    def __init__(self, x: 'float' = None, y: 'float' = None, z: 'float' = None, r: 'float' = None, t: 'float' = None, coordinate_system: 'str' = None):
        super(StagePosition, self).__init__("StagePosition")

        self._init_item(1, DataType.DOUBLE, x, True)
        self._init_item(2, DataType.DOUBLE, y, True)
        self._init_item(3, DataType.DOUBLE, z, True)
        self._init_item(4, DataType.DOUBLE, r, True)
        self._init_item(5, DataType.DOUBLE, t, True)
        self._init_item(6, DataType.STRING, coordinate_system, False)

    def _has_x(self):
        return self._has_item(1)

    @property
    def x(self) -> 'Optional[float]':
        """
        X coordinate.
        """
        return self._get_item(1)

    @x.setter
    def x(self, value: 'Optional[float]'):
        """
        X coordinate.
        """
        self._set_item(1, value)

    def _has_y(self):
        return self._has_item(2)

    @property
    def y(self) -> 'Optional[float]':
        """
        Y coordinate.
        """
        return self._get_item(2)

    @y.setter
    def y(self, value: 'Optional[float]'):
        """
        Y coordinate.
        """
        self._set_item(2, value)

    def _has_z(self):
        return self._has_item(3)

    @property
    def z(self) -> 'Optional[float]':
        """
        Z coordinate.
        """
        return self._get_item(3)

    @z.setter
    def z(self, value: 'Optional[float]'):
        """
        Z coordinate.
        """
        self._set_item(3, value)

    def _has_r(self):
        return self._has_item(4)

    @property
    def r(self) -> 'Optional[float]':
        """
        Rotation.
        """
        return self._get_item(4)

    @r.setter
    def r(self, value: 'Optional[float]'):
        """
        Rotation.
        """
        self._set_item(4, value)

    def _has_t(self):
        return self._has_item(5)

    @property
    def t(self) -> 'Optional[float]':
        """
        Tilt.
        """
        return self._get_item(5)

    @t.setter
    def t(self, value: 'Optional[float]'):
        """
        Tilt.
        """
        self._set_item(5, value)

    def _has_coordinate_system(self):
        return self._has_item(6)

    @property
    def coordinate_system(self) -> 'str':
        """
        The coordinate system in which the position is specified.
        """
        return self._get_item(6)

    @coordinate_system.setter
    def coordinate_system(self, value: 'str'):
        """
        The coordinate system in which the position is specified.
        """
        self._set_item(6, value)


class ManipulatorPosition(StructureBase):
    """
    The structure representing a manipulator position.
    
    :param x: X coordinate.
    
    :param y: Y coordinate.
    
    :param z: Z coordinate.
    
    :param r: Rotation.
    """
    def __init__(self, x: 'float' = None, y: 'float' = None, z: 'float' = None, r: 'float' = None):
        super(ManipulatorPosition, self).__init__("ManipulatorPosition")

        self._init_item(1, DataType.DOUBLE, x, True)
        self._init_item(2, DataType.DOUBLE, y, True)
        self._init_item(3, DataType.DOUBLE, z, True)
        self._init_item(4, DataType.DOUBLE, r, True)

    def _has_x(self):
        return self._has_item(1)

    @property
    def x(self) -> 'Optional[float]':
        """
        X coordinate.
        """
        return self._get_item(1)

    @x.setter
    def x(self, value: 'Optional[float]'):
        """
        X coordinate.
        """
        self._set_item(1, value)

    def _has_y(self):
        return self._has_item(2)

    @property
    def y(self) -> 'Optional[float]':
        """
        Y coordinate.
        """
        return self._get_item(2)

    @y.setter
    def y(self, value: 'Optional[float]'):
        """
        Y coordinate.
        """
        self._set_item(2, value)

    def _has_z(self):
        return self._has_item(3)

    @property
    def z(self) -> 'Optional[float]':
        """
        Z coordinate.
        """
        return self._get_item(3)

    @z.setter
    def z(self, value: 'Optional[float]'):
        """
        Z coordinate.
        """
        self._set_item(3, value)

    def _has_r(self):
        return self._has_item(4)

    @property
    def r(self) -> 'Optional[float]':
        """
        Rotation.
        """
        return self._get_item(4)

    @r.setter
    def r(self, value: 'Optional[float]'):
        """
        Rotation.
        """
        self._set_item(4, value)


class MoveSettings(StructureBase):
    """
    The collection of additional options for a stage move.
    
    :param rotate_compucentric: The option specifies if compucentric rotation should be used in the move.
    
    :param link_z_y: The option specifies if z-y compensation should be used in the move.
    
    :param link_z_b: The option specifies if z-beta compensation should be used in the move. Supported for Compustage movements only.
    
    :param z_cap_move: The option specifies if the CapProbe sensor should be used in the move.
    
    :param tilt_compucentric: The option specifies if compucentric tilt should be used in the move.
    """
    def __init__(self, rotate_compucentric: 'bool' = None, link_z_y: 'bool' = None, link_z_b: 'bool' = None, z_cap_move: 'bool' = None, tilt_compucentric: 'bool' = None):
        super(MoveSettings, self).__init__("MoveSettings")

        self._init_item(1, DataType.BOOL, rotate_compucentric, True)
        self._init_item(2, DataType.BOOL, link_z_y, True)
        self._init_item(3, DataType.BOOL, link_z_b, True)
        self._init_item(4, DataType.BOOL, z_cap_move, True)
        self._init_item(5, DataType.BOOL, tilt_compucentric, True)

    def _has_rotate_compucentric(self):
        return self._has_item(1)

    @property
    def rotate_compucentric(self) -> 'Optional[bool]':
        """
        The option specifies if compucentric rotation should be used in the move.
        """
        return self._get_item(1)

    @rotate_compucentric.setter
    def rotate_compucentric(self, value: 'Optional[bool]'):
        """
        The option specifies if compucentric rotation should be used in the move.
        """
        self._set_item(1, value)

    def _has_link_z_y(self):
        return self._has_item(2)

    @property
    def link_z_y(self) -> 'Optional[bool]':
        """
        The option specifies if z-y compensation should be used in the move.
        """
        return self._get_item(2)

    @link_z_y.setter
    def link_z_y(self, value: 'Optional[bool]'):
        """
        The option specifies if z-y compensation should be used in the move.
        """
        self._set_item(2, value)

    def _has_link_z_b(self):
        return self._has_item(3)

    @property
    def link_z_b(self) -> 'Optional[bool]':
        """
        The option specifies if z-beta compensation should be used in the move. Supported for Compustage movements only.
        """
        return self._get_item(3)

    @link_z_b.setter
    def link_z_b(self, value: 'Optional[bool]'):
        """
        The option specifies if z-beta compensation should be used in the move. Supported for Compustage movements only.
        """
        self._set_item(3, value)

    def _has_z_cap_move(self):
        return self._has_item(4)

    @property
    def z_cap_move(self) -> 'Optional[bool]':
        """
        The option specifies if the CapProbe sensor should be used in the move.
        """
        return self._get_item(4)

    @z_cap_move.setter
    def z_cap_move(self, value: 'Optional[bool]'):
        """
        The option specifies if the CapProbe sensor should be used in the move.
        """
        self._set_item(4, value)

    def _has_tilt_compucentric(self):
        return self._has_item(5)

    @property
    def tilt_compucentric(self) -> 'Optional[bool]':
        """
        The option specifies if compucentric tilt should be used in the move.
        """
        return self._get_item(5)

    @tilt_compucentric.setter
    def tilt_compucentric(self, value: 'Optional[bool]'):
        """
        The option specifies if compucentric tilt should be used in the move.
        """
        self._set_item(5, value)


class ImageMatch(StructureBase):
    """
    Information about match of a template in an image.
    
    :param center: Point structure containing coordinates of the center of the match in the original image, in pixels.
    
    :param score: Level of confidence with which the template matching algorithm matched the template, in range between [0, 1] corresponding to 0% - 100%.
    """
    def __init__(self, center: 'structures.Point' = None, score: 'float' = None):
        super(ImageMatch, self).__init__("ImageMatch")

        self._init_item(1, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), center, False)
        self._init_item(2, DataType.DOUBLE, score, True)

    def _has_center(self):
        return self._has_item(1)

    @property
    def center(self) -> 'structures.Point':
        """
        Point structure containing coordinates of the center of the match in the original image, in pixels.
        """
        return self._get_item(1)

    @center.setter
    def center(self, value: 'structures.Point'):
        """
        Point structure containing coordinates of the center of the match in the original image, in pixels.
        """
        self._set_item(1, value)

    def _has_score(self):
        return self._has_item(2)

    @property
    def score(self) -> 'Optional[float]':
        """
        Level of confidence with which the template matching algorithm matched the template, in range between [0, 1] corresponding to 0% - 100%.
        """
        return self._get_item(2)

    @score.setter
    def score(self, value: 'Optional[float]'):
        """
        Level of confidence with which the template matching algorithm matched the template, in range between [0, 1] corresponding to 0% - 100%.
        """
        self._set_item(2, value)


class StreamPatternDefinition(StructureBase):
    """
    The definition of a stream pattern.
    
    :param raw_points: Patterning points in a raw form.
    
    :param repeat_count: The number of patterning cycles.
    
    :param bit_depth: Bit depth of the point coordinates. It can be either 12 or 16.
    """
    def __init__(self, raw_points: 'bytes' = None, repeat_count: 'int' = 0, bit_depth: 'int' = 0):
        super(StreamPatternDefinition, self).__init__("StreamPatternDefinition")

        self._init_item(1, DataType.BYTE_ARRAY, raw_points, False)
        self._init_item(2, DataType.INT32, repeat_count, False)
        self._init_item(3, DataType.INT32, bit_depth, False)

    def _has_raw_points(self):
        return self._has_item(1)

    @property
    def raw_points(self) -> 'bytes':
        """
        Patterning points in a raw form.
        """
        return self._get_item(1)

    @raw_points.setter
    def raw_points(self, value: 'bytes'):
        """
        Patterning points in a raw form.
        """
        self._set_item(1, value)

    def _has_repeat_count(self):
        return self._has_item(2)

    @property
    def repeat_count(self) -> 'int':
        """
        The number of patterning cycles.
        """
        return self._get_item(2)

    @repeat_count.setter
    def repeat_count(self, value: 'int'):
        """
        The number of patterning cycles.
        """
        self._set_item(2, value)

    def _has_bit_depth(self):
        return self._has_item(3)

    @property
    def bit_depth(self) -> 'int':
        """
        Bit depth of the point coordinates. It can be either 12 or 16.
        """
        return self._get_item(3)

    @bit_depth.setter
    def bit_depth(self, value: 'int'):
        """
        Bit depth of the point coordinates. It can be either 12 or 16.
        """
        self._set_item(3, value)


class StreamPatternPoint(StructureBase):
    """
    The stream pattern point.
    
    :param x: The X coordinate of a point.
    
    :param y: The Y coordinate of a point.
    
    :param dwell_time: The dwell time in seconds.
    
    :param flags: The bit mask for additional settings. Blank from file is reverted here.
    """
    def __init__(self, x: 'int' = 0, y: 'int' = 0, dwell_time: 'float' = 0.0, flags: 'int' = 0):
        super(StreamPatternPoint, self).__init__("StreamPatternPoint")

        self._init_item(1, DataType.INT32, x, False)
        self._init_item(2, DataType.INT32, y, False)
        self._init_item(3, DataType.DOUBLE, dwell_time, False)
        self._init_item(4, DataType.INT32, flags, False)

    def _has_x(self):
        return self._has_item(1)

    @property
    def x(self) -> 'int':
        """
        The X coordinate of a point.
        """
        return self._get_item(1)

    @x.setter
    def x(self, value: 'int'):
        """
        The X coordinate of a point.
        """
        self._set_item(1, value)

    def _has_y(self):
        return self._has_item(2)

    @property
    def y(self) -> 'int':
        """
        The Y coordinate of a point.
        """
        return self._get_item(2)

    @y.setter
    def y(self, value: 'int'):
        """
        The Y coordinate of a point.
        """
        self._set_item(2, value)

    def _has_dwell_time(self):
        return self._has_item(3)

    @property
    def dwell_time(self) -> 'float':
        """
        The dwell time in seconds.
        """
        return self._get_item(3)

    @dwell_time.setter
    def dwell_time(self, value: 'float'):
        """
        The dwell time in seconds.
        """
        self._set_item(3, value)

    def _has_flags(self):
        return self._has_item(4)

    @property
    def flags(self) -> 'int':
        """
        The bit mask for additional settings. Blank from file is reverted here.
        """
        return self._get_item(4)

    @flags.setter
    def flags(self, value: 'int'):
        """
        The bit mask for additional settings. Blank from file is reverted here.
        """
        self._set_item(4, value)


class BitmapPatternDefinition(StructureBase):
    """
    The definition of a bitmap pattern.
    
    :param raw_points: Patterning points in a raw form.
    
    :param width: The width of the bitmap in pixels.
    
    :param height: The height of the bitmap in pixels.
    """
    def __init__(self, raw_points: 'bytes' = None, width: 'int' = 0, height: 'int' = 0):
        super(BitmapPatternDefinition, self).__init__("BitmapPatternDefinition")

        self._init_item(1, DataType.BYTE_ARRAY, raw_points, False)
        self._init_item(2, DataType.INT32, width, False)
        self._init_item(3, DataType.INT32, height, False)

    def _has_raw_points(self):
        return self._has_item(1)

    @property
    def raw_points(self) -> 'bytes':
        """
        Patterning points in a raw form.
        """
        return self._get_item(1)

    @raw_points.setter
    def raw_points(self, value: 'bytes'):
        """
        Patterning points in a raw form.
        """
        self._set_item(1, value)

    def _has_width(self):
        return self._has_item(2)

    @property
    def width(self) -> 'int':
        """
        The width of the bitmap in pixels.
        """
        return self._get_item(2)

    @width.setter
    def width(self, value: 'int'):
        """
        The width of the bitmap in pixels.
        """
        self._set_item(2, value)

    def _has_height(self):
        return self._has_item(3)

    @property
    def height(self) -> 'int':
        """
        The height of the bitmap in pixels.
        """
        return self._get_item(3)

    @height.setter
    def height(self, value: 'int'):
        """
        The height of the bitmap in pixels.
        """
        self._set_item(3, value)


class BitmapPatternPoint(StructureBase):
    """
    The bitmap pattern point.
    
    :param dwell_time_coefficient: The coefficient used for blue color. Range is <0,1>.
    
    :param flags: If flags are not zero, dwell time coefficient is used for green and red colors instead.
    """
    def __init__(self, dwell_time_coefficient: 'float' = 0.0, flags: 'int' = 0):
        super(BitmapPatternPoint, self).__init__("BitmapPatternPoint")

        self._init_item(1, DataType.DOUBLE, dwell_time_coefficient, False)
        self._init_item(2, DataType.INT32, flags, False)

    def _has_dwell_time_coefficient(self):
        return self._has_item(1)

    @property
    def dwell_time_coefficient(self) -> 'float':
        """
        The coefficient used for blue color. Range is <0,1>.
        """
        return self._get_item(1)

    @dwell_time_coefficient.setter
    def dwell_time_coefficient(self, value: 'float'):
        """
        The coefficient used for blue color. Range is <0,1>.
        """
        self._set_item(1, value)

    def _has_flags(self):
        return self._has_item(2)

    @property
    def flags(self) -> 'int':
        """
        If flags are not zero, dwell time coefficient is used for green and red colors instead.
        """
        return self._get_item(2)

    @flags.setter
    def flags(self, value: 'int'):
        """
        If flags are not zero, dwell time coefficient is used for green and red colors instead.
        """
        self._set_item(2, value)


class GetRtmPositionSettings(StructureBase):
    """
    The structure specifying the setting of the get real time positions method.
    
    :param pattern_ids: Specify which patterns should be used to retrieve positions from the RTM. If the list is empty, all patterns will be used.
    
    :param coordinate_system: Specify the coordinate system of the retrieved positions. Maps to RtmCoordinateSystem enumeration.
    """
    def __init__(self, pattern_ids: 'List[int]' = None, coordinate_system: 'int' = None):
        super(GetRtmPositionSettings, self).__init__("GetRtmPositionSettings")

        self._init_item(1, DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.INT32), pattern_ids, True)
        self._init_item(2, DataType.INT32, coordinate_system, True)

    def _has_pattern_ids(self):
        return self._has_item(1)

    @property
    def pattern_ids(self) -> 'Optional[List[int]]':
        """
        Specify which patterns should be used to retrieve positions from the RTM. If the list is empty, all patterns will be used.
        """
        return self._get_item(1)

    @pattern_ids.setter
    def pattern_ids(self, value: 'Optional[List[int]]'):
        """
        Specify which patterns should be used to retrieve positions from the RTM. If the list is empty, all patterns will be used.
        """
        self._set_item(1, value)

    def _has_coordinate_system(self):
        return self._has_item(2)

    @property
    def coordinate_system(self) -> 'Optional[int]':
        """
        Specify the coordinate system of the retrieved positions. Maps to RtmCoordinateSystem enumeration.
        """
        return self._get_item(2)

    @coordinate_system.setter
    def coordinate_system(self, value: 'Optional[int]'):
        """
        Specify the coordinate system of the retrieved positions. Maps to RtmCoordinateSystem enumeration.
        """
        self._set_item(2, value)


class RtmPositionSet(StructureBase):
    """
    The set of pattern point positions.
    
    :param pattern_id: The ID of the pattern.
    
    :param coordinate_system: The coordinate system of the pattern point positions. Maps to RtmCoordinateSystem enumeration.
    
    :param raw_positions: The raw data sent from the AutoScript Server. Do not use directly.
    """
    def __init__(self, pattern_id: 'int' = 0, coordinate_system: 'int' = 0, raw_positions: 'bytes' = None):
        super(RtmPositionSet, self).__init__("RtmPositionSet")

        self._init_item(1, DataType.INT32, pattern_id, False)
        self._init_item(2, DataType.INT32, coordinate_system, False)
        self._init_item(3, DataType.BYTE_ARRAY, raw_positions, False)

    def _has_pattern_id(self):
        return self._has_item(1)

    @property
    def pattern_id(self) -> 'int':
        """
        The ID of the pattern.
        """
        return self._get_item(1)

    @pattern_id.setter
    def pattern_id(self, value: 'int'):
        """
        The ID of the pattern.
        """
        self._set_item(1, value)

    def _has_coordinate_system(self):
        return self._has_item(2)

    @property
    def coordinate_system(self) -> 'int':
        """
        The coordinate system of the pattern point positions. Maps to RtmCoordinateSystem enumeration.
        """
        return self._get_item(2)

    @coordinate_system.setter
    def coordinate_system(self, value: 'int'):
        """
        The coordinate system of the pattern point positions. Maps to RtmCoordinateSystem enumeration.
        """
        self._set_item(2, value)

    def _has_raw_positions(self):
        return self._has_item(3)

    @property
    def raw_positions(self) -> 'bytes':
        """
        The raw data sent from the AutoScript Server. Do not use directly.
        """
        return self._get_item(3)

    @raw_positions.setter
    def raw_positions(self, value: 'bytes'):
        """
        The raw data sent from the AutoScript Server. Do not use directly.
        """
        self._set_item(3, value)


class RtmPosition(StructureBase):
    """
    The pattern point position.
    
    :param x: The X coordinate of a point.
    
    :param y: The Y coordinate of a point.
    """
    def __init__(self, x: 'int' = 0, y: 'int' = 0):
        super(RtmPosition, self).__init__("RtmPosition")

        self._init_item(1, DataType.INT32, x, False)
        self._init_item(2, DataType.INT32, y, False)

    def _has_x(self):
        return self._has_item(1)

    @property
    def x(self) -> 'int':
        """
        The X coordinate of a point.
        """
        return self._get_item(1)

    @x.setter
    def x(self, value: 'int'):
        """
        The X coordinate of a point.
        """
        self._set_item(1, value)

    def _has_y(self):
        return self._has_item(2)

    @property
    def y(self) -> 'int':
        """
        The Y coordinate of a point.
        """
        return self._get_item(2)

    @y.setter
    def y(self, value: 'int'):
        """
        The Y coordinate of a point.
        """
        self._set_item(2, value)


class GetRtmDataSettings(StructureBase):
    """
    The structure specifying the setting of the get_data() method.
    
    :param pattern_ids: Specify which patterns should be used to retrieve data from the RTM. If the list is empty, all patterns will be used.
    
    :param wait_for_next_data: When the flag is set to True, the get_data() function call is waiting for next data. Once the data is available the call returns back to script. When no data was captured and patterning job was finished, None is returned. The flag can be useful for patterning jobs where one pass takes a lot of time and user doesn't want to process the same data twice.
    """
    def __init__(self, pattern_ids: 'List[int]' = None, wait_for_next_data: 'bool' = None):
        super(GetRtmDataSettings, self).__init__("GetRtmDataSettings")

        self._init_item(1, DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.INT32), pattern_ids, True)
        self._init_item(2, DataType.BOOL, wait_for_next_data, True)

    def _has_pattern_ids(self):
        return self._has_item(1)

    @property
    def pattern_ids(self) -> 'Optional[List[int]]':
        """
        Specify which patterns should be used to retrieve data from the RTM. If the list is empty, all patterns will be used.
        """
        return self._get_item(1)

    @pattern_ids.setter
    def pattern_ids(self, value: 'Optional[List[int]]'):
        """
        Specify which patterns should be used to retrieve data from the RTM. If the list is empty, all patterns will be used.
        """
        self._set_item(1, value)

    def _has_wait_for_next_data(self):
        return self._has_item(2)

    @property
    def wait_for_next_data(self) -> 'Optional[bool]':
        """
        When the flag is set to True, the get_data() function call is waiting for next data. Once the data is available the call returns back to script. When no data was captured and patterning job was finished, None is returned. The flag can be useful for patterning jobs where one pass takes a lot of time and user doesn't want to process the same data twice.
        """
        return self._get_item(2)

    @wait_for_next_data.setter
    def wait_for_next_data(self, value: 'Optional[bool]'):
        """
        When the flag is set to True, the get_data() function call is waiting for next data. Once the data is available the call returns back to script. When no data was captured and patterning job was finished, None is returned. The flag can be useful for patterning jobs where one pass takes a lot of time and user doesn't want to process the same data twice.
        """
        self._set_item(2, value)


class RtmDataSet(StructureBase):
    """
    The pattern point data set.
    
    :param pattern_id: The ID of the pattern.
    
    :param raw_values: The raw data sent via network.
    """
    def __init__(self, pattern_id: 'int' = 0, raw_values: 'bytes' = None):
        super(RtmDataSet, self).__init__("RtmDataSet")

        self._init_item(1, DataType.INT32, pattern_id, False)
        self._init_item(2, DataType.BYTE_ARRAY, raw_values, False)

    def _has_pattern_id(self):
        return self._has_item(1)

    @property
    def pattern_id(self) -> 'int':
        """
        The ID of the pattern.
        """
        return self._get_item(1)

    @pattern_id.setter
    def pattern_id(self, value: 'int'):
        """
        The ID of the pattern.
        """
        self._set_item(1, value)

    def _has_raw_values(self):
        return self._has_item(2)

    @property
    def raw_values(self) -> 'bytes':
        """
        The raw data sent via network.
        """
        return self._get_item(2)

    @raw_values.setter
    def raw_values(self, value: 'bytes'):
        """
        The raw data sent via network.
        """
        self._set_item(2, value)


class LargeImageHeader(StructureBase):
    def __init__(self, image_id: 'str' = None, preview: 'structures.AdornedImage' = None, part_count: 'int' = 0):
        super(LargeImageHeader, self).__init__("LargeImageHeader")

        self._init_item(1, DataType.STRING, image_id, False)
        self._init_item(2, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImage"), preview, False)
        self._init_item(3, DataType.INT32, part_count, False)

    def _has_image_id(self):
        return self._has_item(1)

    @property
    def image_id(self) -> 'str':
        return self._get_item(1)

    @image_id.setter
    def image_id(self, value: 'str'):
        self._set_item(1, value)

    def _has_preview(self):
        return self._has_item(2)

    @property
    def preview(self) -> 'structures.AdornedImage':
        return self._get_item(2)

    @preview.setter
    def preview(self, value: 'structures.AdornedImage'):
        self._set_item(2, value)

    def _has_part_count(self):
        return self._has_item(3)

    @property
    def part_count(self) -> 'int':
        return self._get_item(3)

    @part_count.setter
    def part_count(self, value: 'int'):
        self._set_item(3, value)


class AdornedImageMetadataOpticsScanFieldSize(StructureBase):
    def __init__(self, width: 'float' = 0.0, height: 'float' = 0.0):
        super(AdornedImageMetadataOpticsScanFieldSize, self).__init__("AdornedImageMetadataOpticsScanFieldSize")

        self._init_item(1, DataType.DOUBLE, width, False)
        self._init_item(2, DataType.DOUBLE, height, False)

    def _has_width(self):
        return self._has_item(1)

    @property
    def width(self) -> 'float':
        return self._get_item(1)

    @width.setter
    def width(self, value: 'float'):
        self._set_item(1, value)

    def _has_height(self):
        return self._has_item(2)

    @property
    def height(self) -> 'float':
        return self._get_item(2)

    @height.setter
    def height(self, value: 'float'):
        self._set_item(2, value)


class AdornedImageMetadataAcquisition(StructureBase):
    def __init__(self, acquisition_datetime: 'str' = None, acquisition_id: 'str' = None, acquisition_start_datetime: 'str' = None, beam_type: 'str' = None, column_type: 'str' = None, source_type: 'str' = None):
        super(AdornedImageMetadataAcquisition, self).__init__("AdornedImageMetadataAcquisition")

        self._init_item(1, DataType.STRING, acquisition_datetime, True)
        self._init_item(2, DataType.STRING, acquisition_id, True)
        self._init_item(3, DataType.STRING, acquisition_start_datetime, True)
        self._init_item(4, DataType.STRING, beam_type, True)
        self._init_item(5, DataType.STRING, column_type, True)
        self._init_item(6, DataType.STRING, source_type, True)

    def _has_acquisition_datetime(self):
        return self._has_item(1)

    @property
    def acquisition_datetime(self) -> 'Optional[str]':
        return self._get_item(1)

    @acquisition_datetime.setter
    def acquisition_datetime(self, value: 'Optional[str]'):
        self._set_item(1, value)

    def _has_acquisition_id(self):
        return self._has_item(2)

    @property
    def acquisition_id(self) -> 'Optional[str]':
        return self._get_item(2)

    @acquisition_id.setter
    def acquisition_id(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_acquisition_start_datetime(self):
        return self._has_item(3)

    @property
    def acquisition_start_datetime(self) -> 'Optional[str]':
        return self._get_item(3)

    @acquisition_start_datetime.setter
    def acquisition_start_datetime(self, value: 'Optional[str]'):
        self._set_item(3, value)

    def _has_beam_type(self):
        return self._has_item(4)

    @property
    def beam_type(self) -> 'Optional[str]':
        return self._get_item(4)

    @beam_type.setter
    def beam_type(self, value: 'Optional[str]'):
        self._set_item(4, value)

    def _has_column_type(self):
        return self._has_item(5)

    @property
    def column_type(self) -> 'Optional[str]':
        return self._get_item(5)

    @column_type.setter
    def column_type(self, value: 'Optional[str]'):
        self._set_item(5, value)

    def _has_source_type(self):
        return self._has_item(6)

    @property
    def source_type(self) -> 'Optional[str]':
        return self._get_item(6)

    @source_type.setter
    def source_type(self, value: 'Optional[str]'):
        self._set_item(6, value)


class AdornedImageMetadataBinaryResult(StructureBase):
    def __init__(self, acquisition_unit: 'str' = None, bits_per_pixel: 'int' = None, black_level: 'float' = None, composition_type: 'str' = None, detector: 'str' = None, detector_index: 'int' = None, digital_brightness: 'float' = None, digital_contrast: 'float' = None, encoding: 'str' = None, filter_frame_count: 'int' = None, filter_type: 'str' = None, gamma: 'float' = None, intensity_offset: 'float' = None, intensity_scale: 'float' = None, pixel_value_maximum: 'float' = None, pixel_value_minimum: 'float' = None, pixel_value_mean: 'float' = None, pixel_value_standard_deviation: 'float' = None, recursive_filter_coefficient: 'float' = None, reference_transformation: 'str' = None, sharpness: 'float' = None, sharpness_algorithm: 'str' = None, sigma: 'float' = None, white_level: 'float' = None, acquisition_area: 'structures.Rectangle' = None, image_size: 'structures.Point' = None, offset: 'structures.Point' = None, pixel_size: 'structures.Point' = None):
        super(AdornedImageMetadataBinaryResult, self).__init__("AdornedImageMetadataBinaryResult")

        self._init_item(2, DataType.STRING, acquisition_unit, True)
        self._init_item(3, DataType.INT32, bits_per_pixel, True)
        self._init_item(4, DataType.DOUBLE, black_level, True)
        self._init_item(5, DataType.STRING, composition_type, True)
        self._init_item(6, DataType.STRING, detector, True)
        self._init_item(7, DataType.INT32, detector_index, True)
        self._init_item(8, DataType.DOUBLE, digital_brightness, True)
        self._init_item(9, DataType.DOUBLE, digital_contrast, True)
        self._init_item(10, DataType.STRING, encoding, True)
        self._init_item(11, DataType.INT32, filter_frame_count, True)
        self._init_item(12, DataType.STRING, filter_type, True)
        self._init_item(13, DataType.DOUBLE, gamma, True)
        self._init_item(15, DataType.DOUBLE, intensity_offset, True)
        self._init_item(16, DataType.DOUBLE, intensity_scale, True)
        self._init_item(19, DataType.DOUBLE, pixel_value_maximum, True)
        self._init_item(20, DataType.DOUBLE, pixel_value_minimum, True)
        self._init_item(21, DataType.DOUBLE, pixel_value_mean, True)
        self._init_item(22, DataType.DOUBLE, pixel_value_standard_deviation, True)
        self._init_item(23, DataType.DOUBLE, recursive_filter_coefficient, True)
        self._init_item(24, DataType.STRING, reference_transformation, True)
        self._init_item(25, DataType.DOUBLE, sharpness, True)
        self._init_item(26, DataType.STRING, sharpness_algorithm, True)
        self._init_item(27, DataType.DOUBLE, sigma, True)
        self._init_item(28, DataType.DOUBLE, white_level, True)
        self._init_item(29, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), acquisition_area, True)
        self._init_item(30, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), image_size, True)
        self._init_item(31, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), offset, True)
        self._init_item(32, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), pixel_size, True)

    def _has_acquisition_unit(self):
        return self._has_item(2)

    @property
    def acquisition_unit(self) -> 'Optional[str]':
        return self._get_item(2)

    @acquisition_unit.setter
    def acquisition_unit(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_bits_per_pixel(self):
        return self._has_item(3)

    @property
    def bits_per_pixel(self) -> 'Optional[int]':
        return self._get_item(3)

    @bits_per_pixel.setter
    def bits_per_pixel(self, value: 'Optional[int]'):
        self._set_item(3, value)

    def _has_black_level(self):
        return self._has_item(4)

    @property
    def black_level(self) -> 'Optional[float]':
        return self._get_item(4)

    @black_level.setter
    def black_level(self, value: 'Optional[float]'):
        self._set_item(4, value)

    def _has_composition_type(self):
        return self._has_item(5)

    @property
    def composition_type(self) -> 'Optional[str]':
        return self._get_item(5)

    @composition_type.setter
    def composition_type(self, value: 'Optional[str]'):
        self._set_item(5, value)

    def _has_detector(self):
        return self._has_item(6)

    @property
    def detector(self) -> 'Optional[str]':
        return self._get_item(6)

    @detector.setter
    def detector(self, value: 'Optional[str]'):
        self._set_item(6, value)

    def _has_detector_index(self):
        return self._has_item(7)

    @property
    def detector_index(self) -> 'Optional[int]':
        return self._get_item(7)

    @detector_index.setter
    def detector_index(self, value: 'Optional[int]'):
        self._set_item(7, value)

    def _has_digital_brightness(self):
        return self._has_item(8)

    @property
    def digital_brightness(self) -> 'Optional[float]':
        return self._get_item(8)

    @digital_brightness.setter
    def digital_brightness(self, value: 'Optional[float]'):
        self._set_item(8, value)

    def _has_digital_contrast(self):
        return self._has_item(9)

    @property
    def digital_contrast(self) -> 'Optional[float]':
        return self._get_item(9)

    @digital_contrast.setter
    def digital_contrast(self, value: 'Optional[float]'):
        self._set_item(9, value)

    def _has_encoding(self):
        return self._has_item(10)

    @property
    def encoding(self) -> 'Optional[str]':
        return self._get_item(10)

    @encoding.setter
    def encoding(self, value: 'Optional[str]'):
        self._set_item(10, value)

    def _has_filter_frame_count(self):
        return self._has_item(11)

    @property
    def filter_frame_count(self) -> 'Optional[int]':
        return self._get_item(11)

    @filter_frame_count.setter
    def filter_frame_count(self, value: 'Optional[int]'):
        self._set_item(11, value)

    def _has_filter_type(self):
        return self._has_item(12)

    @property
    def filter_type(self) -> 'Optional[str]':
        return self._get_item(12)

    @filter_type.setter
    def filter_type(self, value: 'Optional[str]'):
        self._set_item(12, value)

    def _has_gamma(self):
        return self._has_item(13)

    @property
    def gamma(self) -> 'Optional[float]':
        return self._get_item(13)

    @gamma.setter
    def gamma(self, value: 'Optional[float]'):
        self._set_item(13, value)

    def _has_intensity_offset(self):
        return self._has_item(15)

    @property
    def intensity_offset(self) -> 'Optional[float]':
        return self._get_item(15)

    @intensity_offset.setter
    def intensity_offset(self, value: 'Optional[float]'):
        self._set_item(15, value)

    def _has_intensity_scale(self):
        return self._has_item(16)

    @property
    def intensity_scale(self) -> 'Optional[float]':
        return self._get_item(16)

    @intensity_scale.setter
    def intensity_scale(self, value: 'Optional[float]'):
        self._set_item(16, value)

    def _has_pixel_value_maximum(self):
        return self._has_item(19)

    @property
    def pixel_value_maximum(self) -> 'Optional[float]':
        return self._get_item(19)

    @pixel_value_maximum.setter
    def pixel_value_maximum(self, value: 'Optional[float]'):
        self._set_item(19, value)

    def _has_pixel_value_minimum(self):
        return self._has_item(20)

    @property
    def pixel_value_minimum(self) -> 'Optional[float]':
        return self._get_item(20)

    @pixel_value_minimum.setter
    def pixel_value_minimum(self, value: 'Optional[float]'):
        self._set_item(20, value)

    def _has_pixel_value_mean(self):
        return self._has_item(21)

    @property
    def pixel_value_mean(self) -> 'Optional[float]':
        return self._get_item(21)

    @pixel_value_mean.setter
    def pixel_value_mean(self, value: 'Optional[float]'):
        self._set_item(21, value)

    def _has_pixel_value_standard_deviation(self):
        return self._has_item(22)

    @property
    def pixel_value_standard_deviation(self) -> 'Optional[float]':
        return self._get_item(22)

    @pixel_value_standard_deviation.setter
    def pixel_value_standard_deviation(self, value: 'Optional[float]'):
        self._set_item(22, value)

    def _has_recursive_filter_coefficient(self):
        return self._has_item(23)

    @property
    def recursive_filter_coefficient(self) -> 'Optional[float]':
        return self._get_item(23)

    @recursive_filter_coefficient.setter
    def recursive_filter_coefficient(self, value: 'Optional[float]'):
        self._set_item(23, value)

    def _has_reference_transformation(self):
        return self._has_item(24)

    @property
    def reference_transformation(self) -> 'Optional[str]':
        return self._get_item(24)

    @reference_transformation.setter
    def reference_transformation(self, value: 'Optional[str]'):
        self._set_item(24, value)

    def _has_sharpness(self):
        return self._has_item(25)

    @property
    def sharpness(self) -> 'Optional[float]':
        return self._get_item(25)

    @sharpness.setter
    def sharpness(self, value: 'Optional[float]'):
        self._set_item(25, value)

    def _has_sharpness_algorithm(self):
        return self._has_item(26)

    @property
    def sharpness_algorithm(self) -> 'Optional[str]':
        return self._get_item(26)

    @sharpness_algorithm.setter
    def sharpness_algorithm(self, value: 'Optional[str]'):
        self._set_item(26, value)

    def _has_sigma(self):
        return self._has_item(27)

    @property
    def sigma(self) -> 'Optional[float]':
        return self._get_item(27)

    @sigma.setter
    def sigma(self, value: 'Optional[float]'):
        self._set_item(27, value)

    def _has_white_level(self):
        return self._has_item(28)

    @property
    def white_level(self) -> 'Optional[float]':
        return self._get_item(28)

    @white_level.setter
    def white_level(self, value: 'Optional[float]'):
        self._set_item(28, value)

    def _has_acquisition_area(self):
        return self._has_item(29)

    @property
    def acquisition_area(self) -> 'Optional[structures.Rectangle]':
        return self._get_item(29)

    @acquisition_area.setter
    def acquisition_area(self, value: 'Optional[structures.Rectangle]'):
        self._set_item(29, value)

    def _has_image_size(self):
        return self._has_item(30)

    @property
    def image_size(self) -> 'Optional[structures.Point]':
        return self._get_item(30)

    @image_size.setter
    def image_size(self, value: 'Optional[structures.Point]'):
        self._set_item(30, value)

    def _has_offset(self):
        return self._has_item(31)

    @property
    def offset(self) -> 'Optional[structures.Point]':
        return self._get_item(31)

    @offset.setter
    def offset(self, value: 'Optional[structures.Point]'):
        self._set_item(31, value)

    def _has_pixel_size(self):
        return self._has_item(32)

    @property
    def pixel_size(self) -> 'Optional[structures.Point]':
        return self._get_item(32)

    @pixel_size.setter
    def pixel_size(self, value: 'Optional[structures.Point]'):
        self._set_item(32, value)


class AdornedImageMetadataCore(StructureBase):
    def __init__(self, application_computer_name: 'str' = None, application_software: 'str' = None, application_software_version: 'str' = None, comment: 'str' = None, file_date_time: 'str' = None, file_name: 'str' = None, guid: 'str' = None, md5_checksum: 'bytes' = None, parent_guid: 'str' = None, private_checksum: 'bytes' = None, user_id: 'str' = None):
        super(AdornedImageMetadataCore, self).__init__("AdornedImageMetadataCore")

        self._init_item(1, DataType.STRING, application_computer_name, True)
        self._init_item(2, DataType.STRING, application_software, True)
        self._init_item(3, DataType.STRING, application_software_version, True)
        self._init_item(4, DataType.STRING, comment, True)
        self._init_item(5, DataType.STRING, file_date_time, True)
        self._init_item(6, DataType.STRING, file_name, True)
        self._init_item(7, DataType.STRING, guid, True)
        self._init_item(8, DataType.BYTE_ARRAY, md5_checksum, True)
        self._init_item(9, DataType.STRING, parent_guid, True)
        self._init_item(10, DataType.BYTE_ARRAY, private_checksum, True)
        self._init_item(11, DataType.STRING, user_id, True)

    def _has_application_computer_name(self):
        return self._has_item(1)

    @property
    def application_computer_name(self) -> 'Optional[str]':
        return self._get_item(1)

    @application_computer_name.setter
    def application_computer_name(self, value: 'Optional[str]'):
        self._set_item(1, value)

    def _has_application_software(self):
        return self._has_item(2)

    @property
    def application_software(self) -> 'Optional[str]':
        return self._get_item(2)

    @application_software.setter
    def application_software(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_application_software_version(self):
        return self._has_item(3)

    @property
    def application_software_version(self) -> 'Optional[str]':
        return self._get_item(3)

    @application_software_version.setter
    def application_software_version(self, value: 'Optional[str]'):
        self._set_item(3, value)

    def _has_comment(self):
        return self._has_item(4)

    @property
    def comment(self) -> 'Optional[str]':
        return self._get_item(4)

    @comment.setter
    def comment(self, value: 'Optional[str]'):
        self._set_item(4, value)

    def _has_file_date_time(self):
        return self._has_item(5)

    @property
    def file_date_time(self) -> 'Optional[str]':
        return self._get_item(5)

    @file_date_time.setter
    def file_date_time(self, value: 'Optional[str]'):
        self._set_item(5, value)

    def _has_file_name(self):
        return self._has_item(6)

    @property
    def file_name(self) -> 'Optional[str]':
        return self._get_item(6)

    @file_name.setter
    def file_name(self, value: 'Optional[str]'):
        self._set_item(6, value)

    def _has_guid(self):
        return self._has_item(7)

    @property
    def guid(self) -> 'Optional[str]':
        return self._get_item(7)

    @guid.setter
    def guid(self, value: 'Optional[str]'):
        self._set_item(7, value)

    def _has_md5_checksum(self):
        return self._has_item(8)

    @property
    def md5_checksum(self) -> 'Optional[bytes]':
        return self._get_item(8)

    @md5_checksum.setter
    def md5_checksum(self, value: 'Optional[bytes]'):
        self._set_item(8, value)

    def _has_parent_guid(self):
        return self._has_item(9)

    @property
    def parent_guid(self) -> 'Optional[str]':
        return self._get_item(9)

    @parent_guid.setter
    def parent_guid(self, value: 'Optional[str]'):
        self._set_item(9, value)

    def _has_private_checksum(self):
        return self._has_item(10)

    @property
    def private_checksum(self) -> 'Optional[bytes]':
        return self._get_item(10)

    @private_checksum.setter
    def private_checksum(self, value: 'Optional[bytes]'):
        self._set_item(10, value)

    def _has_user_id(self):
        return self._has_item(11)

    @property
    def user_id(self) -> 'Optional[str]':
        return self._get_item(11)

    @user_id.setter
    def user_id(self, value: 'Optional[str]'):
        self._set_item(11, value)


class AdornedImageMetadataDetector(StructureBase):
    def __init__(self, detector_name: 'str' = None, detector_type: 'str' = None, enabled: 'bool' = None, inserted: 'bool' = None):
        super(AdornedImageMetadataDetector, self).__init__("AdornedImageMetadataDetector")

        self._init_item(1, DataType.STRING, detector_name, True)
        self._init_item(2, DataType.STRING, detector_type, True)
        self._init_item(3, DataType.BOOL, enabled, True)
        self._init_item(4, DataType.BOOL, inserted, True)

    def _has_detector_name(self):
        return self._has_item(1)

    @property
    def detector_name(self) -> 'Optional[str]':
        return self._get_item(1)

    @detector_name.setter
    def detector_name(self, value: 'Optional[str]'):
        self._set_item(1, value)

    def _has_detector_type(self):
        return self._has_item(2)

    @property
    def detector_type(self) -> 'Optional[str]':
        return self._get_item(2)

    @detector_type.setter
    def detector_type(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_enabled(self):
        return self._has_item(3)

    @property
    def enabled(self) -> 'Optional[bool]':
        return self._get_item(3)

    @enabled.setter
    def enabled(self, value: 'Optional[bool]'):
        self._set_item(3, value)

    def _has_inserted(self):
        return self._has_item(4)

    @property
    def inserted(self) -> 'Optional[bool]':
        return self._get_item(4)

    @inserted.setter
    def inserted(self, value: 'Optional[bool]'):
        self._set_item(4, value)


class AdornedImageMetadataEnergyFilterSettings(StructureBase):
    def __init__(self, acceleration_voltage_offset: 'float' = None, drift_tube_voltage: 'float' = None, energy_selection_slit_width: 'float' = None, energy_shift: 'float' = None, entrance_aperture_diameter: 'float' = None, entrance_aperture_type: 'str' = None, energy_selection_slit_inserted: 'bool' = None):
        super(AdornedImageMetadataEnergyFilterSettings, self).__init__("AdornedImageMetadataEnergyFilterSettings")

        self._init_item(1, DataType.DOUBLE, acceleration_voltage_offset, True)
        self._init_item(2, DataType.DOUBLE, drift_tube_voltage, True)
        self._init_item(3, DataType.DOUBLE, energy_selection_slit_width, True)
        self._init_item(4, DataType.DOUBLE, energy_shift, True)
        self._init_item(5, DataType.DOUBLE, entrance_aperture_diameter, True)
        self._init_item(6, DataType.STRING, entrance_aperture_type, True)
        self._init_item(7, DataType.BOOL, energy_selection_slit_inserted, True)

    def _has_acceleration_voltage_offset(self):
        return self._has_item(1)

    @property
    def acceleration_voltage_offset(self) -> 'Optional[float]':
        return self._get_item(1)

    @acceleration_voltage_offset.setter
    def acceleration_voltage_offset(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_drift_tube_voltage(self):
        return self._has_item(2)

    @property
    def drift_tube_voltage(self) -> 'Optional[float]':
        return self._get_item(2)

    @drift_tube_voltage.setter
    def drift_tube_voltage(self, value: 'Optional[float]'):
        self._set_item(2, value)

    def _has_energy_selection_slit_width(self):
        return self._has_item(3)

    @property
    def energy_selection_slit_width(self) -> 'Optional[float]':
        return self._get_item(3)

    @energy_selection_slit_width.setter
    def energy_selection_slit_width(self, value: 'Optional[float]'):
        self._set_item(3, value)

    def _has_energy_shift(self):
        return self._has_item(4)

    @property
    def energy_shift(self) -> 'Optional[float]':
        return self._get_item(4)

    @energy_shift.setter
    def energy_shift(self, value: 'Optional[float]'):
        self._set_item(4, value)

    def _has_entrance_aperture_diameter(self):
        return self._has_item(5)

    @property
    def entrance_aperture_diameter(self) -> 'Optional[float]':
        return self._get_item(5)

    @entrance_aperture_diameter.setter
    def entrance_aperture_diameter(self, value: 'Optional[float]'):
        self._set_item(5, value)

    def _has_entrance_aperture_type(self):
        return self._has_item(6)

    @property
    def entrance_aperture_type(self) -> 'Optional[str]':
        return self._get_item(6)

    @entrance_aperture_type.setter
    def entrance_aperture_type(self, value: 'Optional[str]'):
        self._set_item(6, value)

    def _has_energy_selection_slit_inserted(self):
        return self._has_item(7)

    @property
    def energy_selection_slit_inserted(self) -> 'Optional[bool]':
        return self._get_item(7)

    @energy_selection_slit_inserted.setter
    def energy_selection_slit_inserted(self, value: 'Optional[bool]'):
        self._set_item(7, value)


class AdornedImageMetadataGasInjectionSystemGas(StructureBase):
    def __init__(self, crucible_temperature: 'float' = None, gas_type: 'str' = None):
        super(AdornedImageMetadataGasInjectionSystemGas, self).__init__("AdornedImageMetadataGasInjectionSystemGas")

        self._init_item(1, DataType.DOUBLE, crucible_temperature, True)
        self._init_item(2, DataType.STRING, gas_type, True)

    def _has_crucible_temperature(self):
        return self._has_item(1)

    @property
    def crucible_temperature(self) -> 'Optional[float]':
        return self._get_item(1)

    @crucible_temperature.setter
    def crucible_temperature(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_gas_type(self):
        return self._has_item(2)

    @property
    def gas_type(self) -> 'Optional[str]':
        return self._get_item(2)

    @gas_type.setter
    def gas_type(self, value: 'Optional[str]'):
        self._set_item(2, value)


class AdornedImageMetadataGasInjectionSystem(StructureBase):
    def __init__(self, gases: 'List[structures.AdornedImageMetadataGasInjectionSystemGas]' = None, needle_temperature: 'float' = None, gas_flow_on: 'bool' = None, heater_on: 'bool' = None, needle_state: 'str' = None, port_name: 'str' = None, port_number: 'int' = None):
        super(AdornedImageMetadataGasInjectionSystem, self).__init__("AdornedImageMetadataGasInjectionSystem")

        self._init_item(1, DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataGasInjectionSystemGas")), gases, False)
        self._init_item(2, DataType.DOUBLE, needle_temperature, True)
        self._init_item(3, DataType.BOOL, gas_flow_on, True)
        self._init_item(4, DataType.BOOL, heater_on, True)
        self._init_item(5, DataType.STRING, needle_state, True)
        self._init_item(6, DataType.STRING, port_name, True)
        self._init_item(7, DataType.INT32, port_number, True)

    def _has_gases(self):
        return self._has_item(1)

    @property
    def gases(self) -> 'List[structures.AdornedImageMetadataGasInjectionSystemGas]':
        return self._get_item(1)

    @gases.setter
    def gases(self, value: 'List[structures.AdornedImageMetadataGasInjectionSystemGas]'):
        self._set_item(1, value)

    def _has_needle_temperature(self):
        return self._has_item(2)

    @property
    def needle_temperature(self) -> 'Optional[float]':
        return self._get_item(2)

    @needle_temperature.setter
    def needle_temperature(self, value: 'Optional[float]'):
        self._set_item(2, value)

    def _has_gas_flow_on(self):
        return self._has_item(3)

    @property
    def gas_flow_on(self) -> 'Optional[bool]':
        return self._get_item(3)

    @gas_flow_on.setter
    def gas_flow_on(self, value: 'Optional[bool]'):
        self._set_item(3, value)

    def _has_heater_on(self):
        return self._has_item(4)

    @property
    def heater_on(self) -> 'Optional[bool]':
        return self._get_item(4)

    @heater_on.setter
    def heater_on(self, value: 'Optional[bool]'):
        self._set_item(4, value)

    def _has_needle_state(self):
        return self._has_item(5)

    @property
    def needle_state(self) -> 'Optional[str]':
        return self._get_item(5)

    @needle_state.setter
    def needle_state(self, value: 'Optional[str]'):
        self._set_item(5, value)

    def _has_port_name(self):
        return self._has_item(6)

    @property
    def port_name(self) -> 'Optional[str]':
        return self._get_item(6)

    @port_name.setter
    def port_name(self, value: 'Optional[str]'):
        self._set_item(6, value)

    def _has_port_number(self):
        return self._has_item(7)

    @property
    def port_number(self) -> 'Optional[int]':
        return self._get_item(7)

    @port_number.setter
    def port_number(self, value: 'Optional[int]'):
        self._set_item(7, value)


class AdornedImageMetadataInstrument(StructureBase):
    def __init__(self, acquisition_server: 'str' = None, acquisition_server_version: 'str' = None, computer_name: 'str' = None, control_software: 'str' = None, control_software_version: 'str' = None, instrument_class: 'str' = None, instrument_id: 'str' = None, instrument_model: 'str' = None, manufacturer: 'str' = None):
        super(AdornedImageMetadataInstrument, self).__init__("AdornedImageMetadataInstrument")

        self._init_item(1, DataType.STRING, acquisition_server, True)
        self._init_item(2, DataType.STRING, acquisition_server_version, True)
        self._init_item(3, DataType.STRING, computer_name, True)
        self._init_item(4, DataType.STRING, control_software, True)
        self._init_item(5, DataType.STRING, control_software_version, True)
        self._init_item(6, DataType.STRING, instrument_class, True)
        self._init_item(7, DataType.STRING, instrument_id, True)
        self._init_item(8, DataType.STRING, instrument_model, True)
        self._init_item(9, DataType.STRING, manufacturer, True)

    def _has_acquisition_server(self):
        return self._has_item(1)

    @property
    def acquisition_server(self) -> 'Optional[str]':
        return self._get_item(1)

    @acquisition_server.setter
    def acquisition_server(self, value: 'Optional[str]'):
        self._set_item(1, value)

    def _has_acquisition_server_version(self):
        return self._has_item(2)

    @property
    def acquisition_server_version(self) -> 'Optional[str]':
        return self._get_item(2)

    @acquisition_server_version.setter
    def acquisition_server_version(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_computer_name(self):
        return self._has_item(3)

    @property
    def computer_name(self) -> 'Optional[str]':
        return self._get_item(3)

    @computer_name.setter
    def computer_name(self, value: 'Optional[str]'):
        self._set_item(3, value)

    def _has_control_software(self):
        return self._has_item(4)

    @property
    def control_software(self) -> 'Optional[str]':
        return self._get_item(4)

    @control_software.setter
    def control_software(self, value: 'Optional[str]'):
        self._set_item(4, value)

    def _has_control_software_version(self):
        return self._has_item(5)

    @property
    def control_software_version(self) -> 'Optional[str]':
        return self._get_item(5)

    @control_software_version.setter
    def control_software_version(self, value: 'Optional[str]'):
        self._set_item(5, value)

    def _has_instrument_class(self):
        return self._has_item(6)

    @property
    def instrument_class(self) -> 'Optional[str]':
        return self._get_item(6)

    @instrument_class.setter
    def instrument_class(self, value: 'Optional[str]'):
        self._set_item(6, value)

    def _has_instrument_id(self):
        return self._has_item(7)

    @property
    def instrument_id(self) -> 'Optional[str]':
        return self._get_item(7)

    @instrument_id.setter
    def instrument_id(self, value: 'Optional[str]'):
        self._set_item(7, value)

    def _has_instrument_model(self):
        return self._has_item(8)

    @property
    def instrument_model(self) -> 'Optional[str]':
        return self._get_item(8)

    @instrument_model.setter
    def instrument_model(self, value: 'Optional[str]'):
        self._set_item(8, value)

    def _has_manufacturer(self):
        return self._has_item(9)

    @property
    def manufacturer(self) -> 'Optional[str]':
        return self._get_item(9)

    @manufacturer.setter
    def manufacturer(self, value: 'Optional[str]'):
        self._set_item(9, value)


class AdornedImageMetadataOpticsAperture(StructureBase):
    def __init__(self, diameter: 'float' = None, index: 'int' = None, mechanism_type: 'str' = None, name: 'str' = None, number: 'int' = None, type: 'str' = None, position_offset: 'structures.Point' = None):
        super(AdornedImageMetadataOpticsAperture, self).__init__("AdornedImageMetadataOpticsAperture")

        self._init_item(1, DataType.DOUBLE, diameter, True)
        self._init_item(3, DataType.INT32, index, True)
        self._init_item(4, DataType.STRING, mechanism_type, True)
        self._init_item(5, DataType.STRING, name, True)
        self._init_item(6, DataType.INT32, number, True)
        self._init_item(7, DataType.STRING, type, True)
        self._init_item(8, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), position_offset, True)

    def _has_diameter(self):
        return self._has_item(1)

    @property
    def diameter(self) -> 'Optional[float]':
        return self._get_item(1)

    @diameter.setter
    def diameter(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_index(self):
        return self._has_item(3)

    @property
    def index(self) -> 'Optional[int]':
        return self._get_item(3)

    @index.setter
    def index(self, value: 'Optional[int]'):
        self._set_item(3, value)

    def _has_mechanism_type(self):
        return self._has_item(4)

    @property
    def mechanism_type(self) -> 'Optional[str]':
        return self._get_item(4)

    @mechanism_type.setter
    def mechanism_type(self, value: 'Optional[str]'):
        self._set_item(4, value)

    def _has_name(self):
        return self._has_item(5)

    @property
    def name(self) -> 'Optional[str]':
        return self._get_item(5)

    @name.setter
    def name(self, value: 'Optional[str]'):
        self._set_item(5, value)

    def _has_number(self):
        return self._has_item(6)

    @property
    def number(self) -> 'Optional[int]':
        return self._get_item(6)

    @number.setter
    def number(self, value: 'Optional[int]'):
        self._set_item(6, value)

    def _has_type(self):
        return self._has_item(7)

    @property
    def type(self) -> 'Optional[str]':
        return self._get_item(7)

    @type.setter
    def type(self, value: 'Optional[str]'):
        self._set_item(7, value)

    def _has_position_offset(self):
        return self._has_item(8)

    @property
    def position_offset(self) -> 'Optional[structures.Point]':
        return self._get_item(8)

    @position_offset.setter
    def position_offset(self, value: 'Optional[structures.Point]'):
        self._set_item(8, value)


class AdornedImageMetadataOptics(StructureBase):
    def __init__(self, acceleration_voltage: 'float' = None, apertures: 'List[structures.AdornedImageMetadataOpticsAperture]' = None, beam_convergence: 'float' = None, beam_current: 'float' = None, beam_current_selected: 'float' = None, beam_diameter: 'float' = None, camera_length: 'float' = None, deceleration_voltage: 'float' = None, defocus: 'float' = None, emission_current: 'float' = None, eucentric_working_distance: 'float' = None, extractor_voltage: 'float' = None, fib_l0_voltage: 'float' = None, fib_l1_voltage: 'float' = None, fib_l2_voltage: 'float' = None, focus: 'float' = None, full_scan_field_of_view: 'structures.AdornedImageMetadataOpticsScanFieldSize' = None, landing_energy: 'float' = None, last_measured_screen_current: 'float' = None, sample_pre_tilt_angle: 'float' = None, scan_field_of_view: 'structures.AdornedImageMetadataOpticsScanFieldSize' = None, screen_current: 'float' = None, spherical_aberration: 'float' = None, spot_size: 'float' = None, stem_focus: 'float' = None, wehnelt_bias: 'float' = None, working_distance: 'float' = None, cross_over_on: 'bool' = None, diffraction_focus: 'float' = None, eftem_on: 'bool' = None, gun_filament_settings: 'float' = None, gun_lens_setting: 'float' = None, high_magnification_mode: 'str' = None, illumination_intensity_normalized: 'float' = None, illumination_mode: 'str' = None, illumination_on: 'bool' = None, illumination_type: 'str' = None, nominal_magnification: 'float' = None, objective_lens_mode: 'str' = None, operation_mode: 'str' = None, optical_mode: 'str' = None, probe_mode: 'str' = None, projector_mode: 'str' = None, sample_tilt_correction_is_on: 'bool' = None, spot_index: 'int' = None, tem_operating_sub_mode: 'str' = None, beam_shift: 'structures.Point' = None, beam_tilt: 'structures.Point' = None, c1_lens_intensity: 'float' = None, c2_lens_intensity: 'float' = None, c3_lens_intensity: 'float' = None, condenser_stigmator_raw: 'structures.Point' = None, diffraction_lens_intensity: 'float' = None, diffraction_stigmator_raw: 'structures.Point' = None, fib_steering: 'structures.Point' = None, gun_shift_raw: 'structures.Point' = None, gun_stigmator_raw: 'structures.Point' = None, gun_tilt_raw: 'structures.Point' = None, image_shift: 'structures.Point' = None, intermediate_lens_intensity: 'float' = None, lorentz_lens_intensity: 'float' = None, mini_condenser_lens_intensity: 'float' = None, objective_lens_intensity: 'float' = None, objective_stigmator_raw: 'structures.Point' = None, projector1_lens_intensity: 'float' = None, projector2_lens_intensity: 'float' = None, stigmator_raw: 'structures.Point' = None):
        super(AdornedImageMetadataOptics, self).__init__("AdornedImageMetadataOptics")

        self._init_item(1, DataType.DOUBLE, acceleration_voltage, True)
        self._init_item(2, DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataOpticsAperture")), apertures, False)
        self._init_item(3, DataType.DOUBLE, beam_convergence, True)
        self._init_item(4, DataType.DOUBLE, beam_current, True)
        self._init_item(5, DataType.DOUBLE, beam_current_selected, True)
        self._init_item(6, DataType.DOUBLE, beam_diameter, True)
        self._init_item(12, DataType.DOUBLE, camera_length, True)
        self._init_item(14, DataType.DOUBLE, deceleration_voltage, True)
        self._init_item(15, DataType.DOUBLE, defocus, True)
        self._init_item(18, DataType.DOUBLE, emission_current, True)
        self._init_item(19, DataType.DOUBLE, eucentric_working_distance, True)
        self._init_item(20, DataType.DOUBLE, extractor_voltage, True)
        self._init_item(21, DataType.DOUBLE, fib_l0_voltage, True)
        self._init_item(22, DataType.DOUBLE, fib_l1_voltage, True)
        self._init_item(23, DataType.DOUBLE, fib_l2_voltage, True)
        self._init_item(25, DataType.DOUBLE, focus, True)
        self._init_item(26, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataOpticsScanFieldSize"), full_scan_field_of_view, True)
        self._init_item(30, DataType.DOUBLE, landing_energy, True)
        self._init_item(31, DataType.DOUBLE, last_measured_screen_current, True)
        self._init_item(38, DataType.DOUBLE, sample_pre_tilt_angle, True)
        self._init_item(39, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataOpticsScanFieldSize"), scan_field_of_view, True)
        self._init_item(40, DataType.DOUBLE, screen_current, True)
        self._init_item(41, DataType.DOUBLE, spherical_aberration, True)
        self._init_item(42, DataType.DOUBLE, spot_size, True)
        self._init_item(43, DataType.DOUBLE, stem_focus, True)
        self._init_item(44, DataType.DOUBLE, wehnelt_bias, True)
        self._init_item(45, DataType.DOUBLE, working_distance, True)
        self._init_item(46, DataType.BOOL, cross_over_on, True)
        self._init_item(47, DataType.DOUBLE, diffraction_focus, True)
        self._init_item(48, DataType.BOOL, eftem_on, True)
        self._init_item(49, DataType.DOUBLE, gun_filament_settings, True)
        self._init_item(50, DataType.DOUBLE, gun_lens_setting, True)
        self._init_item(53, DataType.STRING, high_magnification_mode, True)
        self._init_item(54, DataType.DOUBLE, illumination_intensity_normalized, True)
        self._init_item(55, DataType.STRING, illumination_mode, True)
        self._init_item(56, DataType.BOOL, illumination_on, True)
        self._init_item(57, DataType.STRING, illumination_type, True)
        self._init_item(58, DataType.DOUBLE, nominal_magnification, True)
        self._init_item(59, DataType.STRING, objective_lens_mode, True)
        self._init_item(60, DataType.STRING, operation_mode, True)
        self._init_item(61, DataType.STRING, optical_mode, True)
        self._init_item(62, DataType.STRING, probe_mode, True)
        self._init_item(63, DataType.STRING, projector_mode, True)
        self._init_item(64, DataType.BOOL, sample_tilt_correction_is_on, True)
        self._init_item(65, DataType.INT32, spot_index, True)
        self._init_item(67, DataType.STRING, tem_operating_sub_mode, True)
        self._init_item(68, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), beam_shift, True)
        self._init_item(69, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), beam_tilt, True)
        self._init_item(70, DataType.DOUBLE, c1_lens_intensity, True)
        self._init_item(71, DataType.DOUBLE, c2_lens_intensity, True)
        self._init_item(72, DataType.DOUBLE, c3_lens_intensity, True)
        self._init_item(73, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), condenser_stigmator_raw, True)
        self._init_item(74, DataType.DOUBLE, diffraction_lens_intensity, True)
        self._init_item(75, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), diffraction_stigmator_raw, True)
        self._init_item(76, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), fib_steering, True)
        self._init_item(77, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), gun_shift_raw, True)
        self._init_item(78, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), gun_stigmator_raw, True)
        self._init_item(79, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), gun_tilt_raw, True)
        self._init_item(80, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), image_shift, True)
        self._init_item(81, DataType.DOUBLE, intermediate_lens_intensity, True)
        self._init_item(82, DataType.DOUBLE, lorentz_lens_intensity, True)
        self._init_item(83, DataType.DOUBLE, mini_condenser_lens_intensity, True)
        self._init_item(84, DataType.DOUBLE, objective_lens_intensity, True)
        self._init_item(85, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), objective_stigmator_raw, True)
        self._init_item(86, DataType.DOUBLE, projector1_lens_intensity, True)
        self._init_item(87, DataType.DOUBLE, projector2_lens_intensity, True)
        self._init_item(88, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"), stigmator_raw, True)

    def _has_acceleration_voltage(self):
        return self._has_item(1)

    @property
    def acceleration_voltage(self) -> 'Optional[float]':
        return self._get_item(1)

    @acceleration_voltage.setter
    def acceleration_voltage(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_apertures(self):
        return self._has_item(2)

    @property
    def apertures(self) -> 'List[structures.AdornedImageMetadataOpticsAperture]':
        return self._get_item(2)

    @apertures.setter
    def apertures(self, value: 'List[structures.AdornedImageMetadataOpticsAperture]'):
        self._set_item(2, value)

    def _has_beam_convergence(self):
        return self._has_item(3)

    @property
    def beam_convergence(self) -> 'Optional[float]':
        return self._get_item(3)

    @beam_convergence.setter
    def beam_convergence(self, value: 'Optional[float]'):
        self._set_item(3, value)

    def _has_beam_current(self):
        return self._has_item(4)

    @property
    def beam_current(self) -> 'Optional[float]':
        return self._get_item(4)

    @beam_current.setter
    def beam_current(self, value: 'Optional[float]'):
        self._set_item(4, value)

    def _has_beam_current_selected(self):
        return self._has_item(5)

    @property
    def beam_current_selected(self) -> 'Optional[float]':
        return self._get_item(5)

    @beam_current_selected.setter
    def beam_current_selected(self, value: 'Optional[float]'):
        self._set_item(5, value)

    def _has_beam_diameter(self):
        return self._has_item(6)

    @property
    def beam_diameter(self) -> 'Optional[float]':
        return self._get_item(6)

    @beam_diameter.setter
    def beam_diameter(self, value: 'Optional[float]'):
        self._set_item(6, value)

    def _has_camera_length(self):
        return self._has_item(12)

    @property
    def camera_length(self) -> 'Optional[float]':
        return self._get_item(12)

    @camera_length.setter
    def camera_length(self, value: 'Optional[float]'):
        self._set_item(12, value)

    def _has_deceleration_voltage(self):
        return self._has_item(14)

    @property
    def deceleration_voltage(self) -> 'Optional[float]':
        return self._get_item(14)

    @deceleration_voltage.setter
    def deceleration_voltage(self, value: 'Optional[float]'):
        self._set_item(14, value)

    def _has_defocus(self):
        return self._has_item(15)

    @property
    def defocus(self) -> 'Optional[float]':
        return self._get_item(15)

    @defocus.setter
    def defocus(self, value: 'Optional[float]'):
        self._set_item(15, value)

    def _has_emission_current(self):
        return self._has_item(18)

    @property
    def emission_current(self) -> 'Optional[float]':
        return self._get_item(18)

    @emission_current.setter
    def emission_current(self, value: 'Optional[float]'):
        self._set_item(18, value)

    def _has_eucentric_working_distance(self):
        return self._has_item(19)

    @property
    def eucentric_working_distance(self) -> 'Optional[float]':
        return self._get_item(19)

    @eucentric_working_distance.setter
    def eucentric_working_distance(self, value: 'Optional[float]'):
        self._set_item(19, value)

    def _has_extractor_voltage(self):
        return self._has_item(20)

    @property
    def extractor_voltage(self) -> 'Optional[float]':
        return self._get_item(20)

    @extractor_voltage.setter
    def extractor_voltage(self, value: 'Optional[float]'):
        self._set_item(20, value)

    def _has_fib_l0_voltage(self):
        return self._has_item(21)

    @property
    def fib_l0_voltage(self) -> 'Optional[float]':
        return self._get_item(21)

    @fib_l0_voltage.setter
    def fib_l0_voltage(self, value: 'Optional[float]'):
        self._set_item(21, value)

    def _has_fib_l1_voltage(self):
        return self._has_item(22)

    @property
    def fib_l1_voltage(self) -> 'Optional[float]':
        return self._get_item(22)

    @fib_l1_voltage.setter
    def fib_l1_voltage(self, value: 'Optional[float]'):
        self._set_item(22, value)

    def _has_fib_l2_voltage(self):
        return self._has_item(23)

    @property
    def fib_l2_voltage(self) -> 'Optional[float]':
        return self._get_item(23)

    @fib_l2_voltage.setter
    def fib_l2_voltage(self, value: 'Optional[float]'):
        self._set_item(23, value)

    def _has_focus(self):
        return self._has_item(25)

    @property
    def focus(self) -> 'Optional[float]':
        return self._get_item(25)

    @focus.setter
    def focus(self, value: 'Optional[float]'):
        self._set_item(25, value)

    def _has_full_scan_field_of_view(self):
        return self._has_item(26)

    @property
    def full_scan_field_of_view(self) -> 'Optional[structures.AdornedImageMetadataOpticsScanFieldSize]':
        return self._get_item(26)

    @full_scan_field_of_view.setter
    def full_scan_field_of_view(self, value: 'Optional[structures.AdornedImageMetadataOpticsScanFieldSize]'):
        self._set_item(26, value)

    def _has_landing_energy(self):
        return self._has_item(30)

    @property
    def landing_energy(self) -> 'Optional[float]':
        return self._get_item(30)

    @landing_energy.setter
    def landing_energy(self, value: 'Optional[float]'):
        self._set_item(30, value)

    def _has_last_measured_screen_current(self):
        return self._has_item(31)

    @property
    def last_measured_screen_current(self) -> 'Optional[float]':
        return self._get_item(31)

    @last_measured_screen_current.setter
    def last_measured_screen_current(self, value: 'Optional[float]'):
        self._set_item(31, value)

    def _has_sample_pre_tilt_angle(self):
        return self._has_item(38)

    @property
    def sample_pre_tilt_angle(self) -> 'Optional[float]':
        return self._get_item(38)

    @sample_pre_tilt_angle.setter
    def sample_pre_tilt_angle(self, value: 'Optional[float]'):
        self._set_item(38, value)

    def _has_scan_field_of_view(self):
        return self._has_item(39)

    @property
    def scan_field_of_view(self) -> 'Optional[structures.AdornedImageMetadataOpticsScanFieldSize]':
        return self._get_item(39)

    @scan_field_of_view.setter
    def scan_field_of_view(self, value: 'Optional[structures.AdornedImageMetadataOpticsScanFieldSize]'):
        self._set_item(39, value)

    def _has_screen_current(self):
        return self._has_item(40)

    @property
    def screen_current(self) -> 'Optional[float]':
        return self._get_item(40)

    @screen_current.setter
    def screen_current(self, value: 'Optional[float]'):
        self._set_item(40, value)

    def _has_spherical_aberration(self):
        return self._has_item(41)

    @property
    def spherical_aberration(self) -> 'Optional[float]':
        return self._get_item(41)

    @spherical_aberration.setter
    def spherical_aberration(self, value: 'Optional[float]'):
        self._set_item(41, value)

    def _has_spot_size(self):
        return self._has_item(42)

    @property
    def spot_size(self) -> 'Optional[float]':
        return self._get_item(42)

    @spot_size.setter
    def spot_size(self, value: 'Optional[float]'):
        self._set_item(42, value)

    def _has_stem_focus(self):
        return self._has_item(43)

    @property
    def stem_focus(self) -> 'Optional[float]':
        return self._get_item(43)

    @stem_focus.setter
    def stem_focus(self, value: 'Optional[float]'):
        self._set_item(43, value)

    def _has_wehnelt_bias(self):
        return self._has_item(44)

    @property
    def wehnelt_bias(self) -> 'Optional[float]':
        return self._get_item(44)

    @wehnelt_bias.setter
    def wehnelt_bias(self, value: 'Optional[float]'):
        self._set_item(44, value)

    def _has_working_distance(self):
        return self._has_item(45)

    @property
    def working_distance(self) -> 'Optional[float]':
        return self._get_item(45)

    @working_distance.setter
    def working_distance(self, value: 'Optional[float]'):
        self._set_item(45, value)

    def _has_cross_over_on(self):
        return self._has_item(46)

    @property
    def cross_over_on(self) -> 'Optional[bool]':
        return self._get_item(46)

    @cross_over_on.setter
    def cross_over_on(self, value: 'Optional[bool]'):
        self._set_item(46, value)

    def _has_diffraction_focus(self):
        return self._has_item(47)

    @property
    def diffraction_focus(self) -> 'Optional[float]':
        return self._get_item(47)

    @diffraction_focus.setter
    def diffraction_focus(self, value: 'Optional[float]'):
        self._set_item(47, value)

    def _has_eftem_on(self):
        return self._has_item(48)

    @property
    def eftem_on(self) -> 'Optional[bool]':
        return self._get_item(48)

    @eftem_on.setter
    def eftem_on(self, value: 'Optional[bool]'):
        self._set_item(48, value)

    def _has_gun_filament_settings(self):
        return self._has_item(49)

    @property
    def gun_filament_settings(self) -> 'Optional[float]':
        return self._get_item(49)

    @gun_filament_settings.setter
    def gun_filament_settings(self, value: 'Optional[float]'):
        self._set_item(49, value)

    def _has_gun_lens_setting(self):
        return self._has_item(50)

    @property
    def gun_lens_setting(self) -> 'Optional[float]':
        return self._get_item(50)

    @gun_lens_setting.setter
    def gun_lens_setting(self, value: 'Optional[float]'):
        self._set_item(50, value)

    def _has_high_magnification_mode(self):
        return self._has_item(53)

    @property
    def high_magnification_mode(self) -> 'Optional[str]':
        return self._get_item(53)

    @high_magnification_mode.setter
    def high_magnification_mode(self, value: 'Optional[str]'):
        self._set_item(53, value)

    def _has_illumination_intensity_normalized(self):
        return self._has_item(54)

    @property
    def illumination_intensity_normalized(self) -> 'Optional[float]':
        return self._get_item(54)

    @illumination_intensity_normalized.setter
    def illumination_intensity_normalized(self, value: 'Optional[float]'):
        self._set_item(54, value)

    def _has_illumination_mode(self):
        return self._has_item(55)

    @property
    def illumination_mode(self) -> 'Optional[str]':
        return self._get_item(55)

    @illumination_mode.setter
    def illumination_mode(self, value: 'Optional[str]'):
        self._set_item(55, value)

    def _has_illumination_on(self):
        return self._has_item(56)

    @property
    def illumination_on(self) -> 'Optional[bool]':
        return self._get_item(56)

    @illumination_on.setter
    def illumination_on(self, value: 'Optional[bool]'):
        self._set_item(56, value)

    def _has_illumination_type(self):
        return self._has_item(57)

    @property
    def illumination_type(self) -> 'Optional[str]':
        return self._get_item(57)

    @illumination_type.setter
    def illumination_type(self, value: 'Optional[str]'):
        self._set_item(57, value)

    def _has_nominal_magnification(self):
        return self._has_item(58)

    @property
    def nominal_magnification(self) -> 'Optional[float]':
        return self._get_item(58)

    @nominal_magnification.setter
    def nominal_magnification(self, value: 'Optional[float]'):
        self._set_item(58, value)

    def _has_objective_lens_mode(self):
        return self._has_item(59)

    @property
    def objective_lens_mode(self) -> 'Optional[str]':
        return self._get_item(59)

    @objective_lens_mode.setter
    def objective_lens_mode(self, value: 'Optional[str]'):
        self._set_item(59, value)

    def _has_operation_mode(self):
        return self._has_item(60)

    @property
    def operation_mode(self) -> 'Optional[str]':
        return self._get_item(60)

    @operation_mode.setter
    def operation_mode(self, value: 'Optional[str]'):
        self._set_item(60, value)

    def _has_optical_mode(self):
        return self._has_item(61)

    @property
    def optical_mode(self) -> 'Optional[str]':
        return self._get_item(61)

    @optical_mode.setter
    def optical_mode(self, value: 'Optional[str]'):
        self._set_item(61, value)

    def _has_probe_mode(self):
        return self._has_item(62)

    @property
    def probe_mode(self) -> 'Optional[str]':
        return self._get_item(62)

    @probe_mode.setter
    def probe_mode(self, value: 'Optional[str]'):
        self._set_item(62, value)

    def _has_projector_mode(self):
        return self._has_item(63)

    @property
    def projector_mode(self) -> 'Optional[str]':
        return self._get_item(63)

    @projector_mode.setter
    def projector_mode(self, value: 'Optional[str]'):
        self._set_item(63, value)

    def _has_sample_tilt_correction_is_on(self):
        return self._has_item(64)

    @property
    def sample_tilt_correction_is_on(self) -> 'Optional[bool]':
        return self._get_item(64)

    @sample_tilt_correction_is_on.setter
    def sample_tilt_correction_is_on(self, value: 'Optional[bool]'):
        self._set_item(64, value)

    def _has_spot_index(self):
        return self._has_item(65)

    @property
    def spot_index(self) -> 'Optional[int]':
        return self._get_item(65)

    @spot_index.setter
    def spot_index(self, value: 'Optional[int]'):
        self._set_item(65, value)

    def _has_tem_operating_sub_mode(self):
        return self._has_item(67)

    @property
    def tem_operating_sub_mode(self) -> 'Optional[str]':
        return self._get_item(67)

    @tem_operating_sub_mode.setter
    def tem_operating_sub_mode(self, value: 'Optional[str]'):
        self._set_item(67, value)

    def _has_beam_shift(self):
        return self._has_item(68)

    @property
    def beam_shift(self) -> 'Optional[structures.Point]':
        return self._get_item(68)

    @beam_shift.setter
    def beam_shift(self, value: 'Optional[structures.Point]'):
        self._set_item(68, value)

    def _has_beam_tilt(self):
        return self._has_item(69)

    @property
    def beam_tilt(self) -> 'Optional[structures.Point]':
        return self._get_item(69)

    @beam_tilt.setter
    def beam_tilt(self, value: 'Optional[structures.Point]'):
        self._set_item(69, value)

    def _has_c1_lens_intensity(self):
        return self._has_item(70)

    @property
    def c1_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(70)

    @c1_lens_intensity.setter
    def c1_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(70, value)

    def _has_c2_lens_intensity(self):
        return self._has_item(71)

    @property
    def c2_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(71)

    @c2_lens_intensity.setter
    def c2_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(71, value)

    def _has_c3_lens_intensity(self):
        return self._has_item(72)

    @property
    def c3_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(72)

    @c3_lens_intensity.setter
    def c3_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(72, value)

    def _has_condenser_stigmator_raw(self):
        return self._has_item(73)

    @property
    def condenser_stigmator_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(73)

    @condenser_stigmator_raw.setter
    def condenser_stigmator_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(73, value)

    def _has_diffraction_lens_intensity(self):
        return self._has_item(74)

    @property
    def diffraction_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(74)

    @diffraction_lens_intensity.setter
    def diffraction_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(74, value)

    def _has_diffraction_stigmator_raw(self):
        return self._has_item(75)

    @property
    def diffraction_stigmator_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(75)

    @diffraction_stigmator_raw.setter
    def diffraction_stigmator_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(75, value)

    def _has_fib_steering(self):
        return self._has_item(76)

    @property
    def fib_steering(self) -> 'Optional[structures.Point]':
        return self._get_item(76)

    @fib_steering.setter
    def fib_steering(self, value: 'Optional[structures.Point]'):
        self._set_item(76, value)

    def _has_gun_shift_raw(self):
        return self._has_item(77)

    @property
    def gun_shift_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(77)

    @gun_shift_raw.setter
    def gun_shift_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(77, value)

    def _has_gun_stigmator_raw(self):
        return self._has_item(78)

    @property
    def gun_stigmator_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(78)

    @gun_stigmator_raw.setter
    def gun_stigmator_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(78, value)

    def _has_gun_tilt_raw(self):
        return self._has_item(79)

    @property
    def gun_tilt_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(79)

    @gun_tilt_raw.setter
    def gun_tilt_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(79, value)

    def _has_image_shift(self):
        return self._has_item(80)

    @property
    def image_shift(self) -> 'Optional[structures.Point]':
        return self._get_item(80)

    @image_shift.setter
    def image_shift(self, value: 'Optional[structures.Point]'):
        self._set_item(80, value)

    def _has_intermediate_lens_intensity(self):
        return self._has_item(81)

    @property
    def intermediate_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(81)

    @intermediate_lens_intensity.setter
    def intermediate_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(81, value)

    def _has_lorentz_lens_intensity(self):
        return self._has_item(82)

    @property
    def lorentz_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(82)

    @lorentz_lens_intensity.setter
    def lorentz_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(82, value)

    def _has_mini_condenser_lens_intensity(self):
        return self._has_item(83)

    @property
    def mini_condenser_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(83)

    @mini_condenser_lens_intensity.setter
    def mini_condenser_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(83, value)

    def _has_objective_lens_intensity(self):
        return self._has_item(84)

    @property
    def objective_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(84)

    @objective_lens_intensity.setter
    def objective_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(84, value)

    def _has_objective_stigmator_raw(self):
        return self._has_item(85)

    @property
    def objective_stigmator_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(85)

    @objective_stigmator_raw.setter
    def objective_stigmator_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(85, value)

    def _has_projector1_lens_intensity(self):
        return self._has_item(86)

    @property
    def projector1_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(86)

    @projector1_lens_intensity.setter
    def projector1_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(86, value)

    def _has_projector2_lens_intensity(self):
        return self._has_item(87)

    @property
    def projector2_lens_intensity(self) -> 'Optional[float]':
        return self._get_item(87)

    @projector2_lens_intensity.setter
    def projector2_lens_intensity(self, value: 'Optional[float]'):
        self._set_item(87, value)

    def _has_stigmator_raw(self):
        return self._has_item(88)

    @property
    def stigmator_raw(self) -> 'Optional[structures.Point]':
        return self._get_item(88)

    @stigmator_raw.setter
    def stigmator_raw(self, value: 'Optional[structures.Point]'):
        self._set_item(88, value)


class AdornedImageMetadataSample(StructureBase):
    def __init__(self, region_of_interest_id: 'str' = None, sample_description: 'str' = None, sample_guid: 'str' = None, sample_id: 'str' = None, sample_session_id: 'str' = None):
        super(AdornedImageMetadataSample, self).__init__("AdornedImageMetadataSample")

        self._init_item(1, DataType.STRING, region_of_interest_id, True)
        self._init_item(2, DataType.STRING, sample_description, True)
        self._init_item(3, DataType.STRING, sample_guid, True)
        self._init_item(4, DataType.STRING, sample_id, True)
        self._init_item(5, DataType.STRING, sample_session_id, True)

    def _has_region_of_interest_id(self):
        return self._has_item(1)

    @property
    def region_of_interest_id(self) -> 'Optional[str]':
        return self._get_item(1)

    @region_of_interest_id.setter
    def region_of_interest_id(self, value: 'Optional[str]'):
        self._set_item(1, value)

    def _has_sample_description(self):
        return self._has_item(2)

    @property
    def sample_description(self) -> 'Optional[str]':
        return self._get_item(2)

    @sample_description.setter
    def sample_description(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_sample_guid(self):
        return self._has_item(3)

    @property
    def sample_guid(self) -> 'Optional[str]':
        return self._get_item(3)

    @sample_guid.setter
    def sample_guid(self, value: 'Optional[str]'):
        self._set_item(3, value)

    def _has_sample_id(self):
        return self._has_item(4)

    @property
    def sample_id(self) -> 'Optional[str]':
        return self._get_item(4)

    @sample_id.setter
    def sample_id(self, value: 'Optional[str]'):
        self._set_item(4, value)

    def _has_sample_session_id(self):
        return self._has_item(5)

    @property
    def sample_session_id(self) -> 'Optional[str]':
        return self._get_item(5)

    @sample_session_id.setter
    def sample_session_id(self, value: 'Optional[str]'):
        self._set_item(5, value)


class AdornedImageMetadataScanSettings(StructureBase):
    def __init__(self, scan_rotation: 'float' = None, line_integration_count: 'int' = None, line_interlacing: 'int' = None, mains_lock_on: 'bool' = None, scan_size: 'str' = None, acquisition_time: 'float' = None, dwell_time: 'float' = None, frame_time: 'float' = None, line_time: 'float' = None, scan_area: 'structures.Rectangle' = None):
        super(AdornedImageMetadataScanSettings, self).__init__("AdornedImageMetadataScanSettings")

        self._init_item(6, DataType.DOUBLE, scan_rotation, True)
        self._init_item(7, DataType.INT32, line_integration_count, True)
        self._init_item(8, DataType.INT32, line_interlacing, True)
        self._init_item(9, DataType.BOOL, mains_lock_on, True)
        self._init_item(10, DataType.STRING, scan_size, True)
        self._init_item(11, DataType.DOUBLE, acquisition_time, True)
        self._init_item(12, DataType.DOUBLE, dwell_time, True)
        self._init_item(13, DataType.DOUBLE, frame_time, True)
        self._init_item(14, DataType.DOUBLE, line_time, True)
        self._init_item(15, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Rectangle"), scan_area, True)

    def _has_scan_rotation(self):
        return self._has_item(6)

    @property
    def scan_rotation(self) -> 'Optional[float]':
        return self._get_item(6)

    @scan_rotation.setter
    def scan_rotation(self, value: 'Optional[float]'):
        self._set_item(6, value)

    def _has_line_integration_count(self):
        return self._has_item(7)

    @property
    def line_integration_count(self) -> 'Optional[int]':
        return self._get_item(7)

    @line_integration_count.setter
    def line_integration_count(self, value: 'Optional[int]'):
        self._set_item(7, value)

    def _has_line_interlacing(self):
        return self._has_item(8)

    @property
    def line_interlacing(self) -> 'Optional[int]':
        return self._get_item(8)

    @line_interlacing.setter
    def line_interlacing(self, value: 'Optional[int]'):
        self._set_item(8, value)

    def _has_mains_lock_on(self):
        return self._has_item(9)

    @property
    def mains_lock_on(self) -> 'Optional[bool]':
        return self._get_item(9)

    @mains_lock_on.setter
    def mains_lock_on(self, value: 'Optional[bool]'):
        self._set_item(9, value)

    def _has_scan_size(self):
        return self._has_item(10)

    @property
    def scan_size(self) -> 'Optional[str]':
        return self._get_item(10)

    @scan_size.setter
    def scan_size(self, value: 'Optional[str]'):
        self._set_item(10, value)

    def _has_acquisition_time(self):
        return self._has_item(11)

    @property
    def acquisition_time(self) -> 'Optional[float]':
        return self._get_item(11)

    @acquisition_time.setter
    def acquisition_time(self, value: 'Optional[float]'):
        self._set_item(11, value)

    def _has_dwell_time(self):
        return self._has_item(12)

    @property
    def dwell_time(self) -> 'Optional[float]':
        return self._get_item(12)

    @dwell_time.setter
    def dwell_time(self, value: 'Optional[float]'):
        self._set_item(12, value)

    def _has_frame_time(self):
        return self._has_item(13)

    @property
    def frame_time(self) -> 'Optional[float]':
        return self._get_item(13)

    @frame_time.setter
    def frame_time(self, value: 'Optional[float]'):
        self._set_item(13, value)

    def _has_line_time(self):
        return self._has_item(14)

    @property
    def line_time(self) -> 'Optional[float]':
        return self._get_item(14)

    @line_time.setter
    def line_time(self, value: 'Optional[float]'):
        self._set_item(14, value)

    def _has_scan_area(self):
        return self._has_item(15)

    @property
    def scan_area(self) -> 'Optional[structures.Rectangle]':
        return self._get_item(15)

    @scan_area.setter
    def scan_area(self, value: 'Optional[structures.Rectangle]'):
        self._set_item(15, value)


class AdornedImageMetadataStageSettings(StructureBase):
    def __init__(self, holder_temperature: 'float' = None, holder_type: 'str' = None, sample_loader: 'str' = None, stage_position_string: 'str' = None, stage_position: 'structures.StagePosition' = None):
        super(AdornedImageMetadataStageSettings, self).__init__("AdornedImageMetadataStageSettings")

        self._init_item(1, DataType.DOUBLE, holder_temperature, True)
        self._init_item(2, DataType.STRING, holder_type, True)
        self._init_item(3, DataType.STRING, sample_loader, True)
        self._init_item(4, DataType.STRING, stage_position_string, True)
        self._init_item(5, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="StagePosition"), stage_position, True)

    def _has_holder_temperature(self):
        return self._has_item(1)

    @property
    def holder_temperature(self) -> 'Optional[float]':
        return self._get_item(1)

    @holder_temperature.setter
    def holder_temperature(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_holder_type(self):
        return self._has_item(2)

    @property
    def holder_type(self) -> 'Optional[str]':
        return self._get_item(2)

    @holder_type.setter
    def holder_type(self, value: 'Optional[str]'):
        self._set_item(2, value)

    def _has_sample_loader(self):
        return self._has_item(3)

    @property
    def sample_loader(self) -> 'Optional[str]':
        return self._get_item(3)

    @sample_loader.setter
    def sample_loader(self, value: 'Optional[str]'):
        self._set_item(3, value)

    def _has_stage_position_string(self):
        return self._has_item(4)

    @property
    def stage_position_string(self) -> 'Optional[str]':
        return self._get_item(4)

    @stage_position_string.setter
    def stage_position_string(self, value: 'Optional[str]'):
        self._set_item(4, value)

    def _has_stage_position(self):
        return self._has_item(5)

    @property
    def stage_position(self) -> 'Optional[structures.StagePosition]':
        return self._get_item(5)

    @stage_position.setter
    def stage_position(self, value: 'Optional[structures.StagePosition]'):
        self._set_item(5, value)


class AdornedImageMetadataVacuumProperties(StructureBase):
    def __init__(self, electron_column_pressure: 'float' = None, electron_source_pressure: 'float' = None, ion_column_pressure: 'float' = None, ion_source_pressure: 'float' = None, projection_chamber_pressure: 'float' = None, sample_pressure: 'float' = None, vacuum_mode: 'str' = None):
        super(AdornedImageMetadataVacuumProperties, self).__init__("AdornedImageMetadataVacuumProperties")

        self._init_item(1, DataType.DOUBLE, electron_column_pressure, True)
        self._init_item(2, DataType.DOUBLE, electron_source_pressure, True)
        self._init_item(3, DataType.DOUBLE, ion_column_pressure, True)
        self._init_item(4, DataType.DOUBLE, ion_source_pressure, True)
        self._init_item(5, DataType.DOUBLE, projection_chamber_pressure, True)
        self._init_item(6, DataType.DOUBLE, sample_pressure, True)
        self._init_item(7, DataType.STRING, vacuum_mode, True)

    def _has_electron_column_pressure(self):
        return self._has_item(1)

    @property
    def electron_column_pressure(self) -> 'Optional[float]':
        return self._get_item(1)

    @electron_column_pressure.setter
    def electron_column_pressure(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_electron_source_pressure(self):
        return self._has_item(2)

    @property
    def electron_source_pressure(self) -> 'Optional[float]':
        return self._get_item(2)

    @electron_source_pressure.setter
    def electron_source_pressure(self, value: 'Optional[float]'):
        self._set_item(2, value)

    def _has_ion_column_pressure(self):
        return self._has_item(3)

    @property
    def ion_column_pressure(self) -> 'Optional[float]':
        return self._get_item(3)

    @ion_column_pressure.setter
    def ion_column_pressure(self, value: 'Optional[float]'):
        self._set_item(3, value)

    def _has_ion_source_pressure(self):
        return self._has_item(4)

    @property
    def ion_source_pressure(self) -> 'Optional[float]':
        return self._get_item(4)

    @ion_source_pressure.setter
    def ion_source_pressure(self, value: 'Optional[float]'):
        self._set_item(4, value)

    def _has_projection_chamber_pressure(self):
        return self._has_item(5)

    @property
    def projection_chamber_pressure(self) -> 'Optional[float]':
        return self._get_item(5)

    @projection_chamber_pressure.setter
    def projection_chamber_pressure(self, value: 'Optional[float]'):
        self._set_item(5, value)

    def _has_sample_pressure(self):
        return self._has_item(6)

    @property
    def sample_pressure(self) -> 'Optional[float]':
        return self._get_item(6)

    @sample_pressure.setter
    def sample_pressure(self, value: 'Optional[float]'):
        self._set_item(6, value)

    def _has_vacuum_mode(self):
        return self._has_item(7)

    @property
    def vacuum_mode(self) -> 'Optional[str]':
        return self._get_item(7)

    @vacuum_mode.setter
    def vacuum_mode(self, value: 'Optional[str]'):
        self._set_item(7, value)


class AdornedImageMetadata(StructureBase):
    def __init__(self, acquisition: 'structures.AdornedImageMetadataAcquisition' = None, binary_result: 'structures.AdornedImageMetadataBinaryResult' = None, core: 'structures.AdornedImageMetadataCore' = None, detectors: 'List[structures.AdornedImageMetadataDetector]' = None, energy_filter_settings: 'structures.AdornedImageMetadataEnergyFilterSettings' = None, gas_injection_systems: 'List[structures.AdornedImageMetadataGasInjectionSystem]' = None, instrument: 'structures.AdornedImageMetadataInstrument' = None, optics: 'structures.AdornedImageMetadataOptics' = None, sample: 'structures.AdornedImageMetadataSample' = None, scan_settings: 'structures.AdornedImageMetadataScanSettings' = None, stage_settings: 'structures.AdornedImageMetadataStageSettings' = None, vacuum_properties: 'structures.AdornedImageMetadataVacuumProperties' = None, metadata_as_ini: 'str' = None, metadata_as_xml: 'str' = None):
        super(AdornedImageMetadata, self).__init__("AdornedImageMetadata")

        self._init_item(1, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataAcquisition"), acquisition, False)
        self._init_item(2, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataBinaryResult"), binary_result, False)
        self._init_item(3, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataCore"), core, False)
        self._init_item(4, DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataDetector")), detectors, False)
        self._init_item(5, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataEnergyFilterSettings"), energy_filter_settings, False)
        self._init_item(6, DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataGasInjectionSystem")), gas_injection_systems, False)
        self._init_item(7, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataInstrument"), instrument, False)
        self._init_item(8, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataOptics"), optics, False)
        self._init_item(9, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataSample"), sample, False)
        self._init_item(10, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataScanSettings"), scan_settings, False)
        self._init_item(11, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataStageSettings"), stage_settings, False)
        self._init_item(12, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadataVacuumProperties"), vacuum_properties, False)
        self._init_item(13, DataType.STRING, metadata_as_ini, False)
        self._init_item(14, DataType.STRING, metadata_as_xml, False)

    def _has_acquisition(self):
        return self._has_item(1)

    @property
    def acquisition(self) -> 'structures.AdornedImageMetadataAcquisition':
        return self._get_item(1)

    @acquisition.setter
    def acquisition(self, value: 'structures.AdornedImageMetadataAcquisition'):
        self._set_item(1, value)

    def _has_binary_result(self):
        return self._has_item(2)

    @property
    def binary_result(self) -> 'structures.AdornedImageMetadataBinaryResult':
        return self._get_item(2)

    @binary_result.setter
    def binary_result(self, value: 'structures.AdornedImageMetadataBinaryResult'):
        self._set_item(2, value)

    def _has_core(self):
        return self._has_item(3)

    @property
    def core(self) -> 'structures.AdornedImageMetadataCore':
        return self._get_item(3)

    @core.setter
    def core(self, value: 'structures.AdornedImageMetadataCore'):
        self._set_item(3, value)

    def _has_detectors(self):
        return self._has_item(4)

    @property
    def detectors(self) -> 'List[structures.AdornedImageMetadataDetector]':
        return self._get_item(4)

    @detectors.setter
    def detectors(self, value: 'List[structures.AdornedImageMetadataDetector]'):
        self._set_item(4, value)

    def _has_energy_filter_settings(self):
        return self._has_item(5)

    @property
    def energy_filter_settings(self) -> 'structures.AdornedImageMetadataEnergyFilterSettings':
        return self._get_item(5)

    @energy_filter_settings.setter
    def energy_filter_settings(self, value: 'structures.AdornedImageMetadataEnergyFilterSettings'):
        self._set_item(5, value)

    def _has_gas_injection_systems(self):
        return self._has_item(6)

    @property
    def gas_injection_systems(self) -> 'List[structures.AdornedImageMetadataGasInjectionSystem]':
        return self._get_item(6)

    @gas_injection_systems.setter
    def gas_injection_systems(self, value: 'List[structures.AdornedImageMetadataGasInjectionSystem]'):
        self._set_item(6, value)

    def _has_instrument(self):
        return self._has_item(7)

    @property
    def instrument(self) -> 'structures.AdornedImageMetadataInstrument':
        return self._get_item(7)

    @instrument.setter
    def instrument(self, value: 'structures.AdornedImageMetadataInstrument'):
        self._set_item(7, value)

    def _has_optics(self):
        return self._has_item(8)

    @property
    def optics(self) -> 'structures.AdornedImageMetadataOptics':
        return self._get_item(8)

    @optics.setter
    def optics(self, value: 'structures.AdornedImageMetadataOptics'):
        self._set_item(8, value)

    def _has_sample(self):
        return self._has_item(9)

    @property
    def sample(self) -> 'structures.AdornedImageMetadataSample':
        return self._get_item(9)

    @sample.setter
    def sample(self, value: 'structures.AdornedImageMetadataSample'):
        self._set_item(9, value)

    def _has_scan_settings(self):
        return self._has_item(10)

    @property
    def scan_settings(self) -> 'structures.AdornedImageMetadataScanSettings':
        return self._get_item(10)

    @scan_settings.setter
    def scan_settings(self, value: 'structures.AdornedImageMetadataScanSettings'):
        self._set_item(10, value)

    def _has_stage_settings(self):
        return self._has_item(11)

    @property
    def stage_settings(self) -> 'structures.AdornedImageMetadataStageSettings':
        return self._get_item(11)

    @stage_settings.setter
    def stage_settings(self, value: 'structures.AdornedImageMetadataStageSettings'):
        self._set_item(11, value)

    def _has_vacuum_properties(self):
        return self._has_item(12)

    @property
    def vacuum_properties(self) -> 'structures.AdornedImageMetadataVacuumProperties':
        return self._get_item(12)

    @vacuum_properties.setter
    def vacuum_properties(self, value: 'structures.AdornedImageMetadataVacuumProperties'):
        self._set_item(12, value)

    def _has_metadata_as_ini(self):
        return self._has_item(13)

    @property
    def metadata_as_ini(self) -> 'str':
        return self._get_item(13)

    @metadata_as_ini.setter
    def metadata_as_ini(self, value: 'str'):
        self._set_item(13, value)

    def _has_metadata_as_xml(self):
        return self._has_item(14)

    @property
    def metadata_as_xml(self) -> 'str':
        return self._get_item(14)

    @metadata_as_xml.setter
    def metadata_as_xml(self, value: 'str'):
        self._set_item(14, value)


class AdornedImage(StructureBase):
    """
    The structure representing one microscope image with additional metadata.
    
    :param raw_data: Array containing image data as sent from the AutoScript server.
    
    :param width: Width of the image.
    
    :param height: Height of the image.
    
    :param raw_encoding: Internal encoding of the image. To explain this property use enumeration ImageDataEncoding.
    
    :param bit_depth: Bit depth of the image data.
    
    :param metadata: Metadata containing information about system state at the time this image was captured.
    """
    def __init__(self, raw_data: 'bytes' = None, width: 'int' = 0, height: 'int' = 0, raw_encoding: 'int' = 0, bit_depth: 'int' = 0, metadata: 'structures.AdornedImageMetadata' = None):
        super(AdornedImage, self).__init__("AdornedImage")

        self._init_item(1, DataType.BYTE_ARRAY, raw_data, False)
        self._init_item(2, DataType.INT32, width, False)
        self._init_item(3, DataType.INT32, height, False)
        self._init_item(4, DataType.INT32, raw_encoding, False)
        self._init_item(5, DataType.INT32, bit_depth, False)
        self._init_item(6, DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="AdornedImageMetadata"), metadata, True)

    def _has_raw_data(self):
        return self._has_item(1)

    @property
    def raw_data(self) -> 'bytes':
        """
        Array containing image data as sent from the AutoScript server.
        """
        return self._get_item(1)

    @raw_data.setter
    def raw_data(self, value: 'bytes'):
        """
        Array containing image data as sent from the AutoScript server.
        """
        self._set_item(1, value)

    def _has_width(self):
        return self._has_item(2)

    @property
    def width(self) -> 'int':
        """
        Width of the image.
        """
        return self._get_item(2)

    @width.setter
    def width(self, value: 'int'):
        """
        Width of the image.
        """
        self._set_item(2, value)

    def _has_height(self):
        return self._has_item(3)

    @property
    def height(self) -> 'int':
        """
        Height of the image.
        """
        return self._get_item(3)

    @height.setter
    def height(self, value: 'int'):
        """
        Height of the image.
        """
        self._set_item(3, value)

    def _has_raw_encoding(self):
        return self._has_item(4)

    @property
    def raw_encoding(self) -> 'int':
        """
        Internal encoding of the image. To explain this property use enumeration ImageDataEncoding.
        """
        return self._get_item(4)

    @raw_encoding.setter
    def raw_encoding(self, value: 'int'):
        """
        Internal encoding of the image. To explain this property use enumeration ImageDataEncoding.
        """
        self._set_item(4, value)

    def _has_bit_depth(self):
        return self._has_item(5)

    @property
    def bit_depth(self) -> 'int':
        """
        Bit depth of the image data.
        """
        return self._get_item(5)

    @bit_depth.setter
    def bit_depth(self, value: 'int'):
        """
        Bit depth of the image data.
        """
        self._set_item(5, value)

    def _has_metadata(self):
        return self._has_item(6)

    @property
    def metadata(self) -> 'Optional[structures.AdornedImageMetadata]':
        """
        Metadata containing information about system state at the time this image was captured.
        """
        return self._get_item(6)

    @metadata.setter
    def metadata(self, value: 'Optional[structures.AdornedImageMetadata]'):
        """
        Metadata containing information about system state at the time this image was captured.
        """
        self._set_item(6, value)


class DetectorInsertSettings(StructureBase):
    """
    Settings for the detector insert method.
    
    :param insert_position: Detector insert position. The Stem4Positions enumeration can be used to specify this item.
    """
    def __init__(self, insert_position: 'str' = None):
        super(DetectorInsertSettings, self).__init__("DetectorInsertSettings")

        self._init_item(1, DataType.STRING, insert_position, True)

    def _has_insert_position(self):
        return self._has_item(1)

    @property
    def insert_position(self) -> 'Optional[str]':
        """
        Detector insert position. The Stem4Positions enumeration can be used to specify this item.
        """
        return self._get_item(1)

    @insert_position.setter
    def insert_position(self, value: 'Optional[str]'):
        """
        Detector insert position. The Stem4Positions enumeration can be used to specify this item.
        """
        self._set_item(1, value)


class VacuumSettings(StructureBase):
    """
    Settings for pumping the chamber.
    
    :param mode: Sets target chamber mode. Accepts values from VacuumMode enumeration.
    
    :param gas: Sets target chamber gas type. If set, it needs to be specified whether should be used Low Vacuum or ESEM. Accepts values from VacuumGasType enumeration.
    
    :param pressure: Sets the target chamber pressure.
    """
    def __init__(self, mode: 'str' = None, gas: 'str' = None, pressure: 'float' = None):
        super(VacuumSettings, self).__init__("VacuumSettings")

        self._init_item(1, DataType.STRING, mode, True)
        self._init_item(2, DataType.STRING, gas, True)
        self._init_item(3, DataType.DOUBLE, pressure, True)

    def _has_mode(self):
        return self._has_item(1)

    @property
    def mode(self) -> 'Optional[str]':
        """
        Sets target chamber mode. Accepts values from VacuumMode enumeration.
        """
        return self._get_item(1)

    @mode.setter
    def mode(self, value: 'Optional[str]'):
        """
        Sets target chamber mode. Accepts values from VacuumMode enumeration.
        """
        self._set_item(1, value)

    def _has_gas(self):
        return self._has_item(2)

    @property
    def gas(self) -> 'Optional[str]':
        """
        Sets target chamber gas type. If set, it needs to be specified whether should be used Low Vacuum or ESEM. Accepts values from VacuumGasType enumeration.
        """
        return self._get_item(2)

    @gas.setter
    def gas(self, value: 'Optional[str]'):
        """
        Sets target chamber gas type. If set, it needs to be specified whether should be used Low Vacuum or ESEM. Accepts values from VacuumGasType enumeration.
        """
        self._set_item(2, value)

    def _has_pressure(self):
        return self._has_item(3)

    @property
    def pressure(self) -> 'Optional[float]':
        """
        Sets the target chamber pressure.
        """
        return self._get_item(3)

    @pressure.setter
    def pressure(self, value: 'Optional[float]'):
        """
        Sets the target chamber pressure.
        """
        self._set_item(3, value)


class Variant(StructureBase):
    """
    The structure that can hold integer, float, boolean or string.
    
    :param value_double: 
    
    :param value_int: 
    
    :param value_bool: 
    
    :param value_string: 
    """
    def __init__(self, value_double: 'float' = None, value_int: 'int' = None, value_bool: 'bool' = None, value_string: 'str' = None):
        super(Variant, self).__init__("Variant")

        self._init_item(1, DataType.DOUBLE, value_double, True)
        self._init_item(2, DataType.INT32, value_int, True)
        self._init_item(3, DataType.BOOL, value_bool, True)
        self._init_item(4, DataType.STRING, value_string, True)

    def _has_value_double(self):
        return self._has_item(1)

    @property
    def value_double(self) -> 'Optional[float]':
        return self._get_item(1)

    @value_double.setter
    def value_double(self, value: 'Optional[float]'):
        self._set_item(1, value)

    def _has_value_int(self):
        return self._has_item(2)

    @property
    def value_int(self) -> 'Optional[int]':
        return self._get_item(2)

    @value_int.setter
    def value_int(self, value: 'Optional[int]'):
        self._set_item(2, value)

    def _has_value_bool(self):
        return self._has_item(3)

    @property
    def value_bool(self) -> 'Optional[bool]':
        return self._get_item(3)

    @value_bool.setter
    def value_bool(self, value: 'Optional[bool]'):
        self._set_item(3, value)

    def _has_value_string(self):
        return self._has_item(4)

    @property
    def value_string(self) -> 'Optional[str]':
        return self._get_item(4)

    @value_string.setter
    def value_string(self, value: 'Optional[str]'):
        self._set_item(4, value)


class TemperatureSettings(StructureBase):
    """
    Settings for controlling temperature of heating or cooling stages.
    
    :param target_temperature: Target temperature in Kelvins.
    
    :param ramping_speed: Temperature ramping speed in Kelvins per second.
    
    :param soak_time: Time in seconds to remain at the target temperature after it has been reached within the specified tolerance.
    
    :param tolerance: Minimum desired difference between target and actual temperatures, in Kelvins.
    
    :param timeout: Maximum time the temperature ramping can last, in seconds.
    """
    def __init__(self, target_temperature: 'float' = None, ramping_speed: 'float' = None, soak_time: 'float' = None, tolerance: 'float' = None, timeout: 'int' = None):
        super(TemperatureSettings, self).__init__("TemperatureSettings")

        self._init_item(1, DataType.DOUBLE, target_temperature, True)
        self._init_item(2, DataType.DOUBLE, ramping_speed, True)
        self._init_item(3, DataType.DOUBLE, soak_time, True)
        self._init_item(4, DataType.DOUBLE, tolerance, True)
        self._init_item(5, DataType.INT32, timeout, True)

    def _has_target_temperature(self):
        return self._has_item(1)

    @property
    def target_temperature(self) -> 'Optional[float]':
        """
        Target temperature in Kelvins.
        """
        return self._get_item(1)

    @target_temperature.setter
    def target_temperature(self, value: 'Optional[float]'):
        """
        Target temperature in Kelvins.
        """
        self._set_item(1, value)

    def _has_ramping_speed(self):
        return self._has_item(2)

    @property
    def ramping_speed(self) -> 'Optional[float]':
        """
        Temperature ramping speed in Kelvins per second.
        """
        return self._get_item(2)

    @ramping_speed.setter
    def ramping_speed(self, value: 'Optional[float]'):
        """
        Temperature ramping speed in Kelvins per second.
        """
        self._set_item(2, value)

    def _has_soak_time(self):
        return self._has_item(3)

    @property
    def soak_time(self) -> 'Optional[float]':
        """
        Time in seconds to remain at the target temperature after it has been reached within the specified tolerance.
        """
        return self._get_item(3)

    @soak_time.setter
    def soak_time(self, value: 'Optional[float]'):
        """
        Time in seconds to remain at the target temperature after it has been reached within the specified tolerance.
        """
        self._set_item(3, value)

    def _has_tolerance(self):
        return self._has_item(4)

    @property
    def tolerance(self) -> 'Optional[float]':
        """
        Minimum desired difference between target and actual temperatures, in Kelvins.
        """
        return self._get_item(4)

    @tolerance.setter
    def tolerance(self, value: 'Optional[float]'):
        """
        Minimum desired difference between target and actual temperatures, in Kelvins.
        """
        self._set_item(4, value)

    def _has_timeout(self):
        return self._has_item(5)

    @property
    def timeout(self) -> 'Optional[int]':
        """
        Maximum time the temperature ramping can last, in seconds.
        """
        return self._get_item(5)

    @timeout.setter
    def timeout(self, value: 'Optional[int]'):
        """
        Maximum time the temperature ramping can last, in seconds.
        """
        self._set_item(5, value)

