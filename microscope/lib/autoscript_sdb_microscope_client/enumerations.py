# --------------------------------------------------------------------------------------------------
# <auto-generated>
#     This code was generated by a tool.
#     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
#     Template ID: 53
# </auto-generated>
# --------------------------------------------------------------------------------------------------


class BeamType:
    """
    The enumeration of all available beam types.
    
    :param ELECTRON: Electron beam.
    
    :param ION: Ion beam.
    """
    ELECTRON = 1
    """
    Electron beam.
    """
    ION = 2
    """
    Ion beam.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "ELECTRON",
            2: "ION",
            }.get(value, "?")


class ImagingDevice:
    """
    The enumeration of all supported imaging devices.
    
    :param ELECTRON_BEAM: Electron beam.
    
    :param ION_BEAM: Ion beam.
    
    :param CCD_CAMERA: CCD camera.
    
    :param NAV_CAM: Optical camera.
    
    :param IR_CAMERA: Infra red camera.
    
    :param OPTICAL_MICROSCOPE: Optical microscope.
    
    :param VOLUMESCOPE_APPROACH_CAMERA: Microtome approach camera.
    """
    ELECTRON_BEAM = 1
    """
    Electron beam.
    """
    ION_BEAM = 2
    """
    Ion beam.
    """
    CCD_CAMERA = 3
    """
    CCD camera.
    """
    NAV_CAM = 4
    """
    Optical camera.
    """
    IR_CAMERA = 5
    """
    Infra red camera.
    """
    OPTICAL_MICROSCOPE = 6
    """
    Optical microscope.
    """
    VOLUMESCOPE_APPROACH_CAMERA = 7
    """
    Microtome approach camera.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "ELECTRON_BEAM",
            2: "ION_BEAM",
            3: "CCD_CAMERA",
            4: "NAV_CAM",
            5: "IR_CAMERA",
            6: "OPTICAL_MICROSCOPE",
            7: "VOLUMESCOPE_APPROACH_CAMERA",
            }.get(value, "?")


class CoordinateSystem:
    """
    Coordinate system in which stage coordinates are given.
    
    :param SPECIMEN: Coordinate system based on the position on the specimen. This coordinate system is influenced by several adjustments that facilitate navigation on a given specimen. The most important is the link between Z coordinate and working distance. The specimen coordinate system is also used in the main user interface (XTUI) stage control panel.
    
    :param RAW: Coordinate system based solely on location read from stage hardware encoders. This coordinate system is not affected by any adjustments and should bring the stage always to the exactly same position.
    """
    SPECIMEN = "Specimen"
    """
    Coordinate system based on the position on the specimen. This coordinate system is influenced by several adjustments that facilitate navigation on a given specimen. The most important is the link between Z coordinate and working distance. The specimen coordinate system is also used in the main user interface (XTUI) stage control panel.
    """
    RAW = "Raw"
    """
    Coordinate system based solely on location read from stage hardware encoders. This coordinate system is not affected by any adjustments and should bring the stage always to the exactly same position.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Specimen": "SPECIMEN",
            "Raw": "RAW",
            }.get(value, "?")


class ManipulatorCoordinateSystem:
    """
    Coordinate system in which manipulator (EasyLift) coordinates are given.
    
    :param STAGE: Stage coordinates have the origin [0, 0, 0] in eucentric position and the axes X, Y are considered in the plane of the stage (X points to the chamber door). The Z axis has the direction of the normal vector to the plane of the stage.
    
    :param RAW: Raw coordinates correspond to the real axes X, Y, Z, R. X and Y should be in the range (-0.5, 0.5) mm, axis Z should be in the range (Zbase-0.5, Zbase+0.5) mm. Zbase is 16mm when the manipulator is inserted and around 0.0 when the manipulator is retracted. Zbase values are calibrated during Insert/retract alignment.
    """
    STAGE = "Stage"
    """
    Stage coordinates have the origin [0, 0, 0] in eucentric position and the axes X, Y are considered in the plane of the stage (X points to the chamber door). The Z axis has the direction of the normal vector to the plane of the stage.
    """
    RAW = "Raw"
    """
    Raw coordinates correspond to the real axes X, Y, Z, R. X and Y should be in the range (-0.5, 0.5) mm, axis Z should be in the range (Zbase-0.5, Zbase+0.5) mm. Zbase is 16mm when the manipulator is inserted and around 0.0 when the manipulator is retracted. Zbase values are calibrated during Insert/retract alignment.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Stage": "STAGE",
            "Raw": "RAW",
            }.get(value, "?")


class ScanningFilterType:
    """
    The enumeration of all supported scanning filter types.
    
    :param NONE: Live imaging with one frame following the other. The image remains unfiltered for collecting direct images, mostly in Live/Slow scan. This is the raw scanned image with no filtering.
    
    :param AVERAGING: Continuously averages a specified number of frames (2 or more), resulting in a better signal-to-noise ratio. During averaging, the image is updated continuously and actions such as focusing and moving the stage can still be performed. This process will continue until stopped by change of scanning condition or by freezing the result.
    
    :param INTEGRATION: Allows accumulative noise reduction by true integration over a number of frames and freezes the final image. This process continues until the predefined number of frames is reached, and then stops and freezes automatically.
    """
    NONE = 1
    """
    Live imaging with one frame following the other. The image remains unfiltered for collecting direct images, mostly in Live/Slow scan. This is the raw scanned image with no filtering.
    """
    AVERAGING = 2
    """
    Continuously averages a specified number of frames (2 or more), resulting in a better signal-to-noise ratio. During averaging, the image is updated continuously and actions such as focusing and moving the stage can still be performed. This process will continue until stopped by change of scanning condition or by freezing the result.
    """
    INTEGRATION = 3
    """
    Allows accumulative noise reduction by true integration over a number of frames and freezes the final image. This process continues until the predefined number of frames is reached, and then stops and freezes automatically.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "NONE",
            2: "AVERAGING",
            3: "INTEGRATION",
            }.get(value, "?")


class ScanningMode:
    """
    The enumeration of all available scanning modes used for imaging.
    
    :param FULL_FRAME: The image of a whole frame is grabbed.
    
    :param LINE: Only one line of the frame is grabbed.
    
    :param SPOT: Only one pixel of the frame is grabbed.
    
    :param REDUCED_AREA: The specified rectangular area is grabbed.
    
    :param EXTERNAL: The external control of the scanning system is used, such as beam control from an EDX X-ray system.
    
    :param OTHER: Unknown scan mode.
    
    :param CROSSOVER: The image of the electron source tip is grabbed instead of the sample surface.
    """
    FULL_FRAME = 1
    """
    The image of a whole frame is grabbed.
    """
    LINE = 2
    """
    Only one line of the frame is grabbed.
    """
    SPOT = 3
    """
    Only one pixel of the frame is grabbed.
    """
    REDUCED_AREA = 4
    """
    The specified rectangular area is grabbed.
    """
    EXTERNAL = 5
    """
    The external control of the scanning system is used, such as beam control from an EDX X-ray system.
    """
    OTHER = 6
    """
    Unknown scan mode.
    """
    CROSSOVER = 7
    """
    The image of the electron source tip is grabbed instead of the sample surface.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "FULL_FRAME",
            2: "LINE",
            3: "SPOT",
            4: "REDUCED_AREA",
            5: "EXTERNAL",
            6: "OTHER",
            7: "CROSSOVER",
            }.get(value, "?")


class ScanningResolution:
    """
    The enumeration of standard scan resolutions.
    
    :param PRESET_768X512: 
    
    :param PRESET_1536X1024: 
    
    :param PRESET_3072X2048: 
    
    :param PRESET_6144X4096: 
    
    :param PRESET_512X442: 
    
    :param PRESET_1024X884: 
    
    :param PRESET_2048X1768: 
    
    :param PRESET_4096X3536: 
    """
    PRESET_768X512 = "768x512"
    PRESET_1536X1024 = "1536x1024"
    PRESET_3072X2048 = "3072x2048"
    PRESET_6144X4096 = "6144x4096"
    PRESET_512X442 = "512x442"
    PRESET_1024X884 = "1024x884"
    PRESET_2048X1768 = "2048x1768"
    PRESET_4096X3536 = "4096x3536"
    
    @staticmethod
    def explain(value: str):
        return {
            "768x512": "PRESET_768X512",
            "1536x1024": "PRESET_1536X1024",
            "3072x2048": "PRESET_3072X2048",
            "6144x4096": "PRESET_6144X4096",
            "512x442": "PRESET_512X442",
            "1024x884": "PRESET_1024X884",
            "2048x1768": "PRESET_2048X1768",
            "4096x3536": "PRESET_4096X3536",
            }.get(value, "?")


class ImageDataEncoding:
    """
    The enumeration of all available image encoding.
    
    :param UNSIGNED: Usually represents gray scale images.
    
    :param RGB: The order of colors of a pixel is Red, Green, Blue.
    
    :param BGR: The order of colors of a pixel is Blue, Green, Red.
    """
    UNSIGNED = 0
    """
    Usually represents gray scale images.
    """
    RGB = 3
    """
    The order of colors of a pixel is Red, Green, Blue.
    """
    BGR = 5
    """
    The order of colors of a pixel is Blue, Green, Red.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            0: "UNSIGNED",
            3: "RGB",
            5: "BGR",
            }.get(value, "?")


class DetectorMode:
    """
    The enumeration of all available detector modes.
    
    :param NONE: 
    
    :param SECONDARY_ELECTRONS: 
    
    :param SECONDARY_IONS: 
    
    :param BACKSCATTER_ELECTRONS: 
    
    :param CHARGE_NEUTRALIZATION: 
    
    :param DOWN_HOLE_VISIBILITY: 
    
    :param CUSTOM: 
    
    :param SEGMENT_A: 
    
    :param SEGMENT_B: 
    
    :param Z_CONTRAST: 
    
    :param TOPOGRAPHY: 
    
    :param CATHODO_LUMINESCENCE: 
    
    :param MIX: 
    
    :param BRIGHT_FIELD: 
    
    :param DARK_FIELD: 
    
    :param ANGULAR: 
    
    :param ANGULAR_PARTIAL: 
    
    :param ANGULAR_PARTIAL_COMPLEMENT: 
    
    :param CUSTOM2: 
    
    :param CUSTOM3: 
    
    :param A_PLUS_B: 
    
    :param A_MINUS_B: 
    
    :param BEAM_DECELERATION: 
    
    :param LOW_ANGLE: 
    
    :param HIGH_ANGLE: 
    
    :param ANULAR_B: 
    
    :param ANULAR_C: 
    
    :param ANULAR_A: 
    
    :param INNER_MINUS_OUTER: 
    
    :param ALL: 
    
    :param ANULAR_D: 
    
    :param SCINTILLATION: 
    
    :param DARK_FIELD1: 
    
    :param DARK_FIELD2: 
    
    :param DARK_FIELD3: 
    
    :param DARK_FIELD4: 
    
    :param CUSTOM4: 
    
    :param CUSTOM5: 
    """
    NONE = "None"
    SECONDARY_ELECTRONS = "SecondaryElectrons"
    SECONDARY_IONS = "SecondaryIons"
    BACKSCATTER_ELECTRONS = "BackscatterElectrons"
    CHARGE_NEUTRALIZATION = "ChargeNeutralization"
    DOWN_HOLE_VISIBILITY = "DownHoleVisibility"
    CUSTOM = "Custom"
    SEGMENT_A = "SegmentA"
    SEGMENT_B = "SegmentB"
    Z_CONTRAST = "ZContrast"
    TOPOGRAPHY = "Topography"
    CATHODO_LUMINESCENCE = "CathodoLuminescence"
    MIX = "Mix"
    BRIGHT_FIELD = "BrightField"
    DARK_FIELD = "DarkField"
    ANGULAR = "Angular"
    ANGULAR_PARTIAL = "AngularPartial"
    ANGULAR_PARTIAL_COMPLEMENT = "AngularPartialComplement"
    CUSTOM2 = "Custom2"
    CUSTOM3 = "Custom3"
    A_PLUS_B = "AplusB"
    A_MINUS_B = "AminusB"
    BEAM_DECELERATION = "BeamDeceleration"
    LOW_ANGLE = "LowAngle"
    HIGH_ANGLE = "HighAngle"
    ANULAR_B = "AnularB"
    ANULAR_C = "AnularC"
    ANULAR_A = "AnularA"
    INNER_MINUS_OUTER = "InnerMinusOuter"
    ALL = "All"
    ANULAR_D = "AnularD"
    SCINTILLATION = "Scintillation"
    DARK_FIELD1 = "DarkField1"
    DARK_FIELD2 = "DarkField2"
    DARK_FIELD3 = "DarkField3"
    DARK_FIELD4 = "DarkField4"
    CUSTOM4 = "Custom4"
    CUSTOM5 = "Custom5"
    
    @staticmethod
    def explain(value: str):
        return {
            "None": "NONE",
            "SecondaryElectrons": "SECONDARY_ELECTRONS",
            "SecondaryIons": "SECONDARY_IONS",
            "BackscatterElectrons": "BACKSCATTER_ELECTRONS",
            "ChargeNeutralization": "CHARGE_NEUTRALIZATION",
            "DownHoleVisibility": "DOWN_HOLE_VISIBILITY",
            "Custom": "CUSTOM",
            "SegmentA": "SEGMENT_A",
            "SegmentB": "SEGMENT_B",
            "ZContrast": "Z_CONTRAST",
            "Topography": "TOPOGRAPHY",
            "CathodoLuminescence": "CATHODO_LUMINESCENCE",
            "Mix": "MIX",
            "BrightField": "BRIGHT_FIELD",
            "DarkField": "DARK_FIELD",
            "Angular": "ANGULAR",
            "AngularPartial": "ANGULAR_PARTIAL",
            "AngularPartialComplement": "ANGULAR_PARTIAL_COMPLEMENT",
            "Custom2": "CUSTOM2",
            "Custom3": "CUSTOM3",
            "AplusB": "A_PLUS_B",
            "AminusB": "A_MINUS_B",
            "BeamDeceleration": "BEAM_DECELERATION",
            "LowAngle": "LOW_ANGLE",
            "HighAngle": "HIGH_ANGLE",
            "AnularB": "ANULAR_B",
            "AnularC": "ANULAR_C",
            "AnularA": "ANULAR_A",
            "InnerMinusOuter": "INNER_MINUS_OUTER",
            "All": "ALL",
            "AnularD": "ANULAR_D",
            "Scintillation": "SCINTILLATION",
            "DarkField1": "DARK_FIELD1",
            "DarkField2": "DARK_FIELD2",
            "DarkField3": "DARK_FIELD3",
            "DarkField4": "DARK_FIELD4",
            "Custom4": "CUSTOM4",
            "Custom5": "CUSTOM5",
            }.get(value, "?")


class DetectorType:
    """
    The enumeration of all available detector types.
    
    :param NONE: 
    
    :param TLD: 
    
    :param CDEM: 
    
    :param LFD: 
    
    :param GBSD: 
    
    :param GSED: 
    
    :param ETD: 
    
    :param STEM3: 
    
    :param LVD: 
    
    :param LVSED: 
    
    :param ICE: 
    
    :param ABS: 
    
    :param CBS: 
    
    :param ECD: 
    
    :param STEM3_PLUS: 
    
    :param STEM4: 
    
    :param T1: 
    
    :param T2: 
    
    :param T3: 
    
    :param EXTERNAL: 
    """
    NONE = "None"
    TLD = "TLD"
    CDEM = "CDEM"
    LFD = "LFD"
    GBSD = "GBSD"
    GSED = "GSED"
    ETD = "ETD"
    STEM3 = "STEM3"
    LVD = "LVD"
    LVSED = "LVSED"
    ICE = "ICE"
    ABS = "ABS"
    CBS = "CBS"
    ECD = "ECD"
    STEM3_PLUS = "STEM3_GMode"
    STEM4 = "STEM4"
    T1 = "T1"
    T2 = "T2"
    T3 = "T3"
    EXTERNAL = "External"
    
    @staticmethod
    def explain(value: str):
        return {
            "None": "NONE",
            "TLD": "TLD",
            "CDEM": "CDEM",
            "LFD": "LFD",
            "GBSD": "GBSD",
            "GSED": "GSED",
            "ETD": "ETD",
            "STEM3": "STEM3",
            "LVD": "LVD",
            "LVSED": "LVSED",
            "ICE": "ICE",
            "ABS": "ABS",
            "CBS": "CBS",
            "ECD": "ECD",
            "STEM3_GMode": "STEM3_PLUS",
            "STEM4": "STEM4",
            "T1": "T1",
            "T2": "T2",
            "T3": "T3",
            "External": "EXTERNAL",
            }.get(value, "?")


class PatterningMode:
    """
    The enumeration representing modes available for milling.
    
    :param SERIAL: All defined patterns are milled consecutively. Milling is completed on one pattern before moving to the next. Serial patterning is always used with cleaning cross sections as well as regular cross section.
    
    :param PARALLEL: All defined patterns are milled concurrently. For example, if three lines are defined as milling patterns, one pass of the beam will be made on one, then the next, then the third, back to the first, and so on until all three lines are milled to the depth selected for the first line. Parallel patterning is typically used to avoid redeposition of material on adjacent areas as well as to save milling time.
    """
    SERIAL = "Serial"
    """
    All defined patterns are milled consecutively. Milling is completed on one pattern before moving to the next. Serial patterning is always used with cleaning cross sections as well as regular cross section.
    """
    PARALLEL = "Parallel"
    """
    All defined patterns are milled concurrently. For example, if three lines are defined as milling patterns, one pass of the beam will be made on one, then the next, then the third, back to the first, and so on until all three lines are milled to the depth selected for the first line. Parallel patterning is typically used to avoid redeposition of material on adjacent areas as well as to save milling time.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Serial": "SERIAL",
            "Parallel": "PARALLEL",
            }.get(value, "?")


class PatterningState:
    """
    The enumeration contains all patterning states.
    
    :param ERROR: Last job finished with error.
    
    :param IDLE: The patterning is in idle state. No job is running.
    
    :param RUNNING: Patterning job is running.
    
    :param PAUSED: Patterning job is paused.
    """
    ERROR = "Error"
    """
    Last job finished with error.
    """
    IDLE = "Idle"
    """
    The patterning is in idle state. No job is running.
    """
    RUNNING = "Running"
    """
    Patterning job is running.
    """
    PAUSED = "Paused"
    """
    Patterning job is paused.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Error": "ERROR",
            "Idle": "IDLE",
            "Running": "RUNNING",
            "Paused": "PAUSED",
            }.get(value, "?")


class PatternScanDirection:
    """
    The direction of a movement of a scan.
    
    :param BOTTOM_TO_TOP: 
    
    :param TOP_TO_BOTTOM: 
    
    :param RIGHT_TO_LEFT: 
    
    :param LEFT_TO_RIGHT: 
    
    :param DYNAMIC_TOP_TO_BOTTOM: 
    
    :param DYNAMIC_LEFT_TO_RIGHT: 
    
    :param DYNAMIC_ALL_DIRECTIONS: 
    
    :param OUTER_TO_INNER: 
    
    :param INNER_TO_OUTER: 
    
    :param DYNAMIC_INNER_TO_OUTER: 
    """
    BOTTOM_TO_TOP = "BottomToTop"
    TOP_TO_BOTTOM = "TopToBottom"
    RIGHT_TO_LEFT = "RightToLeft"
    LEFT_TO_RIGHT = "LeftToRight"
    DYNAMIC_TOP_TO_BOTTOM = "DynamicTopToBottom"
    DYNAMIC_LEFT_TO_RIGHT = "DynamicLeftToRight"
    DYNAMIC_ALL_DIRECTIONS = "DynamicAllDirections"
    OUTER_TO_INNER = "OuterToInner"
    INNER_TO_OUTER = "InnerToOuter"
    DYNAMIC_INNER_TO_OUTER = "DynamicInnerToOuter"
    
    @staticmethod
    def explain(value: str):
        return {
            "BottomToTop": "BOTTOM_TO_TOP",
            "TopToBottom": "TOP_TO_BOTTOM",
            "RightToLeft": "RIGHT_TO_LEFT",
            "LeftToRight": "LEFT_TO_RIGHT",
            "DynamicTopToBottom": "DYNAMIC_TOP_TO_BOTTOM",
            "DynamicLeftToRight": "DYNAMIC_LEFT_TO_RIGHT",
            "DynamicAllDirections": "DYNAMIC_ALL_DIRECTIONS",
            "OuterToInner": "OUTER_TO_INNER",
            "InnerToOuter": "INNER_TO_OUTER",
            "DynamicInnerToOuter": "DYNAMIC_INNER_TO_OUTER",
            }.get(value, "?")


class PatternScanType:
    """
    Scanning strategy used while patterning.
    
    :param SERPENTINE: The beam proceeds from left to right and back from right to left.
    
    :param RASTER: The beam scans from left to right, then the beam is blanked and returns to the left starting point.
    
    :param CIRCULAR: 
    """
    SERPENTINE = "Serpentine"
    """
    The beam proceeds from left to right and back from right to left.
    """
    RASTER = "Raster"
    """
    The beam scans from left to right, then the beam is blanked and returns to the left starting point.
    """
    CIRCULAR = "Circular"
    
    @staticmethod
    def explain(value: str):
        return {
            "Serpentine": "SERPENTINE",
            "Raster": "RASTER",
            "Circular": "CIRCULAR",
            }.get(value, "?")


class OpticalMode:
    """
    The enumeration of all available optical modes.
    
    :param FIELD_FREE: 
    
    :param IMMERSION: 
    
    :param EDX: 
    
    :param INTERMEDIATE: 
    
    :param CATHODE: 
    
    :param FIB_IMMERSION: 
    
    :param STANDARD: 
    
    :param OPTIPLAN: 
    
    :param OPTITILT: 
    
    :param ANALYTICAL: 
    
    :param VOLUMESCOPE: 
    
    :param FISH_EYE: 
    """
    FIELD_FREE = "FieldFree"
    IMMERSION = "Immersion"
    EDX = "EDX"
    INTERMEDIATE = "Intermediate"
    CATHODE = "Cathode"
    FIB_IMMERSION = "FIBImmersion"
    STANDARD = "Standard"
    OPTIPLAN = "OptiPlan"
    OPTITILT = "OptiTilt"
    ANALYTICAL = "Analytical"
    VOLUMESCOPE = "Volumescope"
    FISH_EYE = "FishEye"
    
    @staticmethod
    def explain(value: str):
        return {
            "FieldFree": "FIELD_FREE",
            "Immersion": "IMMERSION",
            "EDX": "EDX",
            "Intermediate": "INTERMEDIATE",
            "Cathode": "CATHODE",
            "FIBImmersion": "FIB_IMMERSION",
            "Standard": "STANDARD",
            "OptiPlan": "OPTIPLAN",
            "OptiTilt": "OPTITILT",
            "Analytical": "ANALYTICAL",
            "Volumescope": "VOLUMESCOPE",
            "FishEye": "FISH_EYE",
            }.get(value, "?")


class SegmentPolarity:
    """
    The polarity of a detector segment.
    
    :param POSITIVE: The segment is enabled and the polarity is positive.
    
    :param NEUTRAL: The segment is disabled.
    
    :param NEGATIVE: The segment is enabled and the polarity is negative.
    """
    POSITIVE = 1
    """
    The segment is enabled and the polarity is positive.
    """
    NEUTRAL = 0
    """
    The segment is disabled.
    """
    NEGATIVE = -1
    """
    The segment is enabled and the polarity is negative.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "POSITIVE",
            0: "NEUTRAL",
            -1: "NEGATIVE",
            }.get(value, "?")


class DetectorSegment:
    """
    The detector segments.
    
    :param A: 
    
    :param B: 
    
    :param C: 
    
    :param D: 
    
    :param INNER: 
    
    :param ANNULAR_0: 
    
    :param ANNULAR_1: 
    
    :param ANNULAR_2: 
    
    :param ANNULAR_3: 
    
    :param ANNULAR_4: 
    
    :param ANNULAR_5: 
    
    :param ANGULAR_0: 
    
    :param ANGULAR_1: 
    
    :param ANGULAR_2: 
    
    :param ANGULAR_3: 
    
    :param ANGULAR_4: 
    
    :param ANGULAR_5: 
    """
    A = "A"
    B = "B"
    C = "C"
    D = "D"
    INNER = "Inner"
    ANNULAR_0 = "Annular0"
    ANNULAR_1 = "Annular1"
    ANNULAR_2 = "Annular2"
    ANNULAR_3 = "Annular3"
    ANNULAR_4 = "Annular4"
    ANNULAR_5 = "Annular5"
    ANGULAR_0 = "Angular0"
    ANGULAR_1 = "Angular1"
    ANGULAR_2 = "Angular2"
    ANGULAR_3 = "Angular3"
    ANGULAR_4 = "Angular4"
    ANGULAR_5 = "Angular5"
    
    @staticmethod
    def explain(value: str):
        return {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D",
            "Inner": "INNER",
            "Annular0": "ANNULAR_0",
            "Annular1": "ANNULAR_1",
            "Annular2": "ANNULAR_2",
            "Annular3": "ANNULAR_3",
            "Annular4": "ANNULAR_4",
            "Annular5": "ANNULAR_5",
            "Angular0": "ANGULAR_0",
            "Angular1": "ANGULAR_1",
            "Angular2": "ANGULAR_2",
            "Angular3": "ANGULAR_3",
            "Angular4": "ANGULAR_4",
            "Angular5": "ANGULAR_5",
            }.get(value, "?")


class RtmMode:
    """
    The enumeration of available RTM resolution modes.
    
    :param LOW_RESOLUTION: In low-resolution mode, the imaging pipeline is used to retrieve the values of pattern points. Pattern points are mapped to pixels in the image, and multiple pattern points may belong to a single pixel if the image resolution is not as fine as the pattern point positions. When multiple pattern points fall into a pixel, they all have the same value.
    
    :param HIGH_RESOLUTION: In high-resolution mode, the patterning pipeline is used to retrieve the values of pattern points. The values correspond exactly to the positions of the pattern points, no matter what image resolution is used.
    """
    LOW_RESOLUTION = 1
    """
    In low-resolution mode, the imaging pipeline is used to retrieve the values of pattern points. Pattern points are mapped to pixels in the image, and multiple pattern points may belong to a single pixel if the image resolution is not as fine as the pattern point positions. When multiple pattern points fall into a pixel, they all have the same value.
    """
    HIGH_RESOLUTION = 2
    """
    In high-resolution mode, the patterning pipeline is used to retrieve the values of pattern points. The values correspond exactly to the positions of the pattern points, no matter what image resolution is used.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "LOW_RESOLUTION",
            2: "HIGH_RESOLUTION",
            }.get(value, "?")


class RtmCoordinateSystem:
    """
    The enumeration of available RTM coordinate systems.
    
    :param DAC: The positions correspond to the hardware positions. These positions are more precise.
    
    :param IMAGE_PIXELS: The positions correspond to the image pixel positions.
    """
    DAC = 1
    """
    The positions correspond to the hardware positions. These positions are more precise.
    """
    IMAGE_PIXELS = 2
    """
    The positions correspond to the image pixel positions.
    """
    
    @staticmethod
    def explain(value: int):
        return {
            1: "DAC",
            2: "IMAGE_PIXELS",
            }.get(value, "?")


class AutoFunctionMethod:
    """
    The enumeration of all auto function methods.
    
    :param STANDARD: Standard method for wide range of use cases.
    
    :param VOLUMESCOPE: Method based on Volumescope workflow specialized for biological samples.
    
    :param MAX_CONTRAST: Method to prioritize contrast maximization.
    
    :param ONG_ET_AL: Method based on research of Ong et al.
    """
    STANDARD = "Standard"
    """
    Standard method for wide range of use cases.
    """
    VOLUMESCOPE = "Volumescope"
    """
    Method based on Volumescope workflow specialized for biological samples.
    """
    MAX_CONTRAST = "MaxContrast"
    """
    Method to prioritize contrast maximization.
    """
    ONG_ET_AL = "OngEtAl"
    """
    Method based on research of Ong et al.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Standard": "STANDARD",
            "Volumescope": "VOLUMESCOPE",
            "MaxContrast": "MAX_CONTRAST",
            "OngEtAl": "ONG_ET_AL",
            }.get(value, "?")


class ImageFileFormat:
    """
    The enumeration of supported image file formats.
    
    :param TIFF: The data are stored in TIFF file format. The file will also contain metadata describing conditions at image acquisition time.
    
    :param RAW: The file contains only unformatted data.
    """
    TIFF = "tiff"
    """
    The data are stored in TIFF file format. The file will also contain metadata describing conditions at image acquisition time.
    """
    RAW = "raw"
    """
    The file contains only unformatted data.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "tiff": "TIFF",
            "raw": "RAW",
            }.get(value, "?")


class Stem4Positions:
    """
    The enumeration of all available STEM4 positions.
    
    :param IN_LENS: This position should be used only for high resolution imaging in electron column Mode 2 (Immersion). The stage cannot be at the eucentric position.
    
    :param STANDARD: This position should be used for basic STEM imaging and also for lamella lift-out and thinning with STEM end-pointing -- in the last case, insert the STEM before starting the thinning process. The stage can be at the eucentric position and Easylift with MultiChem can be inserted.
    """
    IN_LENS = "InLens"
    """
    This position should be used only for high resolution imaging in electron column Mode 2 (Immersion). The stage cannot be at the eucentric position.
    """
    STANDARD = "Standard"
    """
    This position should be used for basic STEM imaging and also for lamella lift-out and thinning with STEM end-pointing -- in the last case, insert the STEM before starting the thinning process. The stage can be at the eucentric position and Easylift with MultiChem can be inserted.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "InLens": "IN_LENS",
            "Standard": "STANDARD",
            }.get(value, "?")


class AutoLensAlignmentModulationType:
    """
    Available modulation types for automatic lens alignment adjustment routine.
    
    :param AUTOMATIC: The routine uses modulation type selected automatically according to the current conditions.
    
    :param WORKING_DISTANCE: The routine uses modulation based on working distance.
    
    :param HIGH_VOLTAGE: The routine uses modulation based on high voltage.
    """
    AUTOMATIC = "Automatic"
    """
    The routine uses modulation type selected automatically according to the current conditions.
    """
    WORKING_DISTANCE = "WorkingDistance"
    """
    The routine uses modulation based on working distance.
    """
    HIGH_VOLTAGE = "HighVoltage"
    """
    The routine uses modulation based on high voltage.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Automatic": "AUTOMATIC",
            "WorkingDistance": "WORKING_DISTANCE",
            "HighVoltage": "HIGH_VOLTAGE",
            }.get(value, "?")


class LoadLockState:
    """
    The enumeration of all supported LoadLock states.
    
    :param LOADED: LoadLock is loaded.
    
    :param BUSY: LoadLock is busy.
    
    :param UNLOADED: LoadLock is unloaded.
    
    :param ERROR: LoadLock is in error state.
    
    :param OTHER: Undefined state, most likely state is undetermined.
    """
    LOADED = "Loaded"
    """
    LoadLock is loaded.
    """
    BUSY = "Busy"
    """
    LoadLock is busy.
    """
    UNLOADED = "Unloaded"
    """
    LoadLock is unloaded.
    """
    ERROR = "Error"
    """
    LoadLock is in error state.
    """
    OTHER = "Other"
    """
    Undefined state, most likely state is undetermined.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Loaded": "LOADED",
            "Busy": "BUSY",
            "Unloaded": "UNLOADED",
            "Error": "ERROR",
            "Other": "OTHER",
            }.get(value, "?")


class RetractableDeviceState:
    """
    The enumeration of all supported retractable device states.
    
    :param INSERTED: Device is inserted.
    
    :param RETRACTED: Device is retracted.
    
    :param BUSY: Device is busy (inserting/retracting).
    
    :param ERROR: Device is in error state.
    
    :param OTHER: Undefined state, most likely state is undetermined.
    """
    INSERTED = "Inserted"
    """
    Device is inserted.
    """
    RETRACTED = "Retracted"
    """
    Device is retracted.
    """
    BUSY = "Busy"
    """
    Device is busy (inserting/retracting).
    """
    ERROR = "Error"
    """
    Device is in error state.
    """
    OTHER = "Other"
    """
    Undefined state, most likely state is undetermined.
    """
    
    @staticmethod
    def explain(value: str):
        return {
            "Inserted": "INSERTED",
            "Retracted": "RETRACTED",
            "Busy": "BUSY",
            "Error": "ERROR",
            "Other": "OTHER",
            }.get(value, "?")


class AngularCorrectionMode:
    """
    Enumeration of supported angular correction modes.
    
    :param MANUAL: 
    
    :param AUTOMATIC: 
    """
    MANUAL = "Manual"
    AUTOMATIC = "Automatic"
    
    @staticmethod
    def explain(value: str):
        return {
            "Manual": "MANUAL",
            "Automatic": "AUTOMATIC",
            }.get(value, "?")


class VacuumMode:
    """
    Enumeration of supported vacuum modes.
    
    :param HIGH_VACUUM: 
    
    :param LOW_VACUUM: 
    
    :param ESEM: 
    """
    HIGH_VACUUM = "HighVacuum"
    LOW_VACUUM = "LowVacuum"
    ESEM = "ESEM"
    
    @staticmethod
    def explain(value: str):
        return {
            "HighVacuum": "HIGH_VACUUM",
            "LowVacuum": "LOW_VACUUM",
            "ESEM": "ESEM",
            }.get(value, "?")


class VacuumGasType:
    """
    Enumeration of supported vacuum gas types.
    
    :param WATER: 
    
    :param AUXILIARY: 
    
    :param UNKNOWN: 
    
    :param ARGON: 
    """
    WATER = "Water"
    AUXILIARY = "Auxiliary"
    UNKNOWN = "Unknown"
    ARGON = "Argon"
    
    @staticmethod
    def explain(value: str):
        return {
            "Water": "WATER",
            "Auxiliary": "AUXILIARY",
            "Unknown": "UNKNOWN",
            "Argon": "ARGON",
            }.get(value, "?")


class VacuumState:
    """
    Enumeration of supported vacuum states.
    
    :param PUMPING: 
    
    :param PUMPED: 
    
    :param VENTING: 
    
    :param VENTED: 
    
    :param UNKNOWN: 
    
    :param ERROR: 
    
    :param PUMPED_FOR_WAFER_EXCHANGE: 
    """
    PUMPING = "Pumping"
    PUMPED = "Pumped"
    VENTING = "Venting"
    VENTED = "Vented"
    UNKNOWN = "Unknown"
    ERROR = "Error"
    PUMPED_FOR_WAFER_EXCHANGE = "PumpedForWaferExchange"
    
    @staticmethod
    def explain(value: str):
        return {
            "Pumping": "PUMPING",
            "Pumped": "PUMPED",
            "Venting": "VENTING",
            "Vented": "VENTED",
            "Unknown": "UNKNOWN",
            "Error": "ERROR",
            "PumpedForWaferExchange": "PUMPED_FOR_WAFER_EXCHANGE",
            }.get(value, "?")


class MultiChemInsertPosition:
    """
    Enumeration of standard MultiChem insert positions.
    
    :param ELECTRON_DEFAULT: 
    
    :param ION_DEFAULT: 
    
    :param COMPUSTAGE0_DEFAULT: 
    
    :param COMPUSTAGE90_DEFAULT: 
    
    :param DXLARGE_DEPROCESSING: 
    """
    ELECTRON_DEFAULT = "Electron Default"
    ION_DEFAULT = "Ion Default"
    COMPUSTAGE0_DEFAULT = "Compustage 0 Default"
    COMPUSTAGE90_DEFAULT = "Compustage 90 Default"
    DXLARGE_DEPROCESSING = "DX_Large_Deprocessing"
    
    @staticmethod
    def explain(value: str):
        return {
            "Electron Default": "ELECTRON_DEFAULT",
            "Ion Default": "ION_DEFAULT",
            "Compustage 0 Default": "COMPUSTAGE0_DEFAULT",
            "Compustage 90 Default": "COMPUSTAGE90_DEFAULT",
            "DX_Large_Deprocessing": "DXLARGE_DEPROCESSING",
            }.get(value, "?")


class PlasmaGasType:
    """
    Enumeration of gases in Multiple Ion Plasma FIB
    
    :param XENON: 
    
    :param ARGON: 
    
    :param NITROGEN: 
    
    :param OXYGEN: 
    """
    XENON = "Xenon"
    ARGON = "Argon"
    NITROGEN = "Nitrogen"
    OXYGEN = "Oxygen"
    
    @staticmethod
    def explain(value: str):
        return {
            "Xenon": "XENON",
            "Argon": "ARGON",
            "Nitrogen": "NITROGEN",
            "Oxygen": "OXYGEN",
            }.get(value, "?")


class StageAxis:
    """
    Enumeration of stage axes.
    
    :param X: 
    
    :param Y: 
    
    :param Z: 
    
    :param T: 
    
    :param R: 
    """
    X = "X"
    Y = "Y"
    Z = "Z"
    T = "T"
    R = "R"
    
    @staticmethod
    def explain(value: str):
        return {
            "X": "X",
            "Y": "Y",
            "Z": "Z",
            "T": "T",
            "R": "R",
            }.get(value, "?")


class TemperatureStageType:
    """
    Types of temperature stages.
    
    :param NONE: 
    
    :param COOLING_STAGE: 
    
    :param HEATING_STAGE: 
    
    :param MICRO_HEATER: 
    
    :param HIGH_VACUUM_HEATING_STAGE: 
    """
    NONE = "None"
    COOLING_STAGE = "CoolingStage"
    HEATING_STAGE = "HeatingStage"
    MICRO_HEATER = "MicroHeater"
    HIGH_VACUUM_HEATING_STAGE = "HighVacuumHeatingStage"
    
    @staticmethod
    def explain(value: str):
        return {
            "None": "NONE",
            "CoolingStage": "COOLING_STAGE",
            "HeatingStage": "HEATING_STAGE",
            "MicroHeater": "MICRO_HEATER",
            "HighVacuumHeatingStage": "HIGH_VACUUM_HEATING_STAGE",
            }.get(value, "?")


class RegularCrossSectionScanMethod:
    """
    The enumeration of all supported regular cross section pattern scan methods.
    
    :param STAIR_STEP: 
    
    :param MULTI_SCAN: 
    """
    STAIR_STEP = 0
    MULTI_SCAN = 1
    
    @staticmethod
    def explain(value: int):
        return {
            0: "STAIR_STEP",
            1: "MULTI_SCAN",
            }.get(value, "?")


class TemperatureStageHeatShieldType:
    NONE = "None"
    EBSD = "EBSD"
    TOP_DOWN = "TopDown"
    
    @staticmethod
    def explain(value: str):
        return {
            "None": "NONE",
            "EBSD": "EBSD",
            "TopDown": "TOP_DOWN",
            }.get(value, "?")
