# --------------------------------------------------------------------------------------------------
# <auto-generated>
#     This code was generated by a tool.
#     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
#     Template ID: 51
# </auto-generated>
# --------------------------------------------------------------------------------------------------

from typing import List, Union
from autoscript_sdb_microscope_client.structures import Point, Limits, Limits2d, Variant 
from autoscript_core.common import CallRequest, DataType, DataTypeDefinition, UndefinedParameter
from ._dynamic_object_handles import *


class RectanglePattern(object):    
    """
    The pattern of a rectangular shape.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.RectanglePattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: rectangle_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: rectangle_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: rectangle_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: rectangle_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: rectangle_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: rectangle_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: rectangle_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dwell_time(self) -> 'float':        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.dwell_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dwell_time.setter
    def dwell_time(self, value):        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def time(self) -> 'float':        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @time.setter
    def time(self, value):        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_x(self) -> 'float':        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.center_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_x.setter
    def center_x(self, value):        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_y(self) -> 'float':        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.center_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_y.setter
    def center_y(self, value):        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def width(self) -> 'float':        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.width was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @width.setter
    def width(self, value):        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def height(self) -> 'float':        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.height was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @height.setter
    def height(self, value):        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def depth(self) -> 'float':        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.depth was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @depth.setter
    def depth(self, value):        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_direction(self) -> 'str':        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: rectangle_pattern.scan_direction was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_direction.setter
    def scan_direction(self, value):        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_type(self) -> 'str':        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: rectangle_pattern.scan_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_type.setter
    def scan_type(self, value):        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_x(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.overlap_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_x.setter
    def overlap_x(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_y(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.overlap_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_y.setter
    def overlap_y(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_x(self) -> 'float':        
        """
        Sets the pitch X between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.pitch_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_x.setter
    def pitch_x(self, value):        
        """
        Sets the pitch X between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_y(self) -> 'float':        
        """
        Sets the pitch Y between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: rectangle_pattern.pitch_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_y.setter
    def pitch_y(self, value):        
        """
        Sets the pitch Y between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RectanglePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class LinePattern(object):    
    """
    The line shaped pattern.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.LinePattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: line_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: line_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: line_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: line_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: line_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: line_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: line_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dwell_time(self) -> 'float':        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.dwell_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dwell_time.setter
    def dwell_time(self, value):        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def time(self) -> 'float':        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @time.setter
    def time(self, value):        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def length(self) -> 'float':        
        """
        Sets the length of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Length_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.length was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @length.setter
    def length(self, value):        
        """
        Sets the length of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Length_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Overlap_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.overlap was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap.setter
    def overlap(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Overlap_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch(self) -> 'float':        
        """
        Sets the pitch between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Pitch_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.pitch was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch.setter
    def pitch(self, value):        
        """
        Sets the pitch between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Pitch_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def start_x(self) -> 'float':        
        """
        X coordinate of the pattern start position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="StartX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.start_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @start_x.setter
    def start_x(self, value):        
        """
        X coordinate of the pattern start position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="StartX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def start_y(self) -> 'float':        
        """
        Y coordinate of the pattern start position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="StartY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.start_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @start_y.setter
    def start_y(self, value):        
        """
        Y coordinate of the pattern start position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="StartY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def end_x(self) -> 'float':        
        """
        X coordinate of the pattern end position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="EndX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.end_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @end_x.setter
    def end_x(self, value):        
        """
        X coordinate of the pattern end position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="EndX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def end_y(self) -> 'float':        
        """
        Y coordinate of the pattern end position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="EndY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.end_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @end_y.setter
    def end_y(self, value):        
        """
        Y coordinate of the pattern end position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="EndY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def depth(self) -> 'float':        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: line_pattern.depth was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @depth.setter
    def depth(self, value):        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "LinePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class CirclePattern(object):    
    """
    The circular pattern (may be also a ring).
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.CirclePattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: circle_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: circle_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: circle_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: circle_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: circle_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: circle_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: circle_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dwell_time(self) -> 'float':        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.dwell_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dwell_time.setter
    def dwell_time(self, value):        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def time(self) -> 'float':        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @time.setter
    def time(self, value):        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_direction(self) -> 'str':        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: circle_pattern.scan_direction was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_direction.setter
    def scan_direction(self, value):        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_type(self) -> 'str':        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: circle_pattern.scan_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_type.setter
    def scan_type(self, value):        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def inner_diameter(self) -> 'float':        
        """
        Diameter of the inner circle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InnerDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.inner_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @inner_diameter.setter
    def inner_diameter(self, value):        
        """
        Diameter of the inner circle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InnerDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def outer_diameter(self) -> 'float':        
        """
        Diameter of the circle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OuterDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.outer_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @outer_diameter.setter
    def outer_diameter(self, value):        
        """
        Diameter of the circle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OuterDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_x(self) -> 'float':        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.center_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_x.setter
    def center_x(self, value):        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_y(self) -> 'float':        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.center_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_y.setter
    def center_y(self, value):        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_r(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapR_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.overlap_r was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_r.setter
    def overlap_r(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapR_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_t(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapT_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.overlap_t was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_t.setter
    def overlap_t(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapT_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_r(self) -> 'float':        
        """
        Sets the pitch R between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchR_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.pitch_r was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_r.setter
    def pitch_r(self, value):        
        """
        Sets the pitch R between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchR_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_t(self) -> 'float':        
        """
        Sets the pitch T between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchT_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.pitch_t was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_t.setter
    def pitch_t(self, value):        
        """
        Sets the pitch T between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchT_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def depth(self) -> 'float':        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: circle_pattern.depth was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @depth.setter
    def depth(self, value):        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CirclePattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class CleaningCrossSectionPattern(object):    
    """
    The cleaning cross section pattern type.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.CleaningCrossSectionPattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dwell_time(self) -> 'float':        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.dwell_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dwell_time.setter
    def dwell_time(self, value):        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def time(self) -> 'float':        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @time.setter
    def time(self, value):        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_x(self) -> 'float':        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.center_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_x.setter
    def center_x(self, value):        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_y(self) -> 'float':        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.center_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_y.setter
    def center_y(self, value):        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def width(self) -> 'float':        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.width was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @width.setter
    def width(self, value):        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def height(self) -> 'float':        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.height was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @height.setter
    def height(self, value):        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def depth(self) -> 'float':        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.depth was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @depth.setter
    def depth(self, value):        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_direction(self) -> 'str':        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.scan_direction was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_direction.setter
    def scan_direction(self, value):        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_type(self) -> 'str':        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.scan_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_type.setter
    def scan_type(self, value):        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_x(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.overlap_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_x.setter
    def overlap_x(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_y(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.overlap_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_y.setter
    def overlap_y(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_x(self) -> 'float':        
        """
        Sets the pitch X between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.pitch_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_x.setter
    def pitch_x(self, value):        
        """
        Sets the pitch X between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_y(self) -> 'float':        
        """
        Sets the pitch Y between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: cleaning_cross_section_pattern.pitch_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_y.setter
    def pitch_y(self, value):        
        """
        Sets the pitch Y between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "CleaningCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class RegularCrossSectionPattern(object):    
    """
    The regular cross section pattern type.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.RegularCrossSectionPattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: regular_cross_section_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: regular_cross_section_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: regular_cross_section_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: regular_cross_section_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: regular_cross_section_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: regular_cross_section_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: regular_cross_section_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dwell_time(self) -> 'float':        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.dwell_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dwell_time.setter
    def dwell_time(self, value):        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def time(self) -> 'float':        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @time.setter
    def time(self, value):        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_x(self) -> 'float':        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.center_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_x.setter
    def center_x(self, value):        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_y(self) -> 'float':        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.center_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_y.setter
    def center_y(self, value):        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def width(self) -> 'float':        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.width was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @width.setter
    def width(self, value):        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def height(self) -> 'float':        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.height was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @height.setter
    def height(self, value):        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def depth(self) -> 'float':        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.depth was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @depth.setter
    def depth(self, value):        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_direction(self) -> 'str':        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: regular_cross_section_pattern.scan_direction was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_direction.setter
    def scan_direction(self, value):        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_type(self) -> 'str':        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: regular_cross_section_pattern.scan_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_type.setter
    def scan_type(self, value):        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_x(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.overlap_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_x.setter
    def overlap_x(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def overlap_y(self) -> 'float':        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.overlap_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @overlap_y.setter
    def overlap_y(self, value):        
        """
        Sets the beam diameter overlap.
        """
        call_request = CallRequest(object_id=self.__id, method_name="OverlapY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_x(self) -> 'float':        
        """
        Sets the pitch X between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.pitch_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_x.setter
    def pitch_x(self, value):        
        """
        Sets the pitch X between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pitch_y(self) -> 'float':        
        """
        Sets the pitch Y between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.pitch_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pitch_y.setter
    def pitch_y(self, value):        
        """
        Sets the pitch Y between two spots.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PitchY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_ratio(self) -> 'float':        
        """
        Gets or sets the ratio between the dose delivered at the first line and the dose delivered at the last line of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanRatio_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: regular_cross_section_pattern.scan_ratio was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_ratio.setter
    def scan_ratio(self, value):        
        """
        Gets or sets the ratio between the dose delivered at the first line and the dose delivered at the last line of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanRatio_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "RegularCrossSectionPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class StreamPattern(object):    
    """
    The stream file pattern type.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.StreamPattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: stream_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: stream_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: stream_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: stream_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: stream_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: stream_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: stream_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_x(self) -> 'float':        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.center_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_x.setter
    def center_x(self, value):        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_y(self) -> 'float':        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: stream_pattern.center_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_y.setter
    def center_y(self, value):        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "StreamPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class BitmapPattern(object):    
    """
    The bitmap pattern type.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.BitmapPattern"

    @property
    def _handle(self):
        return self.__handle


    @property
    def application_file(self) -> 'str':        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: bitmap_pattern.application_file was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @application_file.setter
    def application_file(self, value):        
        """
        Name of the application file.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ApplicationFile_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def beam_type(self) -> 'int':        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: bitmap_pattern.beam_type was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @beam_type.setter
    def beam_type(self, value):        
        """
        The beam (either electron or ion) used for patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="BeamType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def rotation(self) -> 'float':        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.rotation was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @rotation.setter
    def rotation(self, value):        
        """
        Pattern rotation angle.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Rotation_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_type(self) -> 'str':        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: bitmap_pattern.gas_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_type.setter
    def gas_type(self, value):        
        """
        The name of the gas that must be used to pattern this shape (or empty string if no gas is to be used).
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def gas_flow(self) -> 'List[float]':        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE):
            raise TypeError("Incompatible type: bitmap_pattern.gas_flow was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @gas_flow.setter
    def gas_flow(self, value):        
        """
        Sets the custom gas flow for the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="GasFlow_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.DOUBLE)], parameters=[self.__handle, value])
        if isinstance(value, (list, tuple)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def id(self) -> 'int':        
        """
        A unique pattern identifier.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Id_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: bitmap_pattern.id was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def defocus(self) -> 'float':        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.defocus was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @defocus.setter
    def defocus(self, value):        
        """
        The defocus (WD change) of the beam. It allows focusing above (negative value) or below (positive value) the sample surface.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Defocus_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def pass_count(self) -> 'int':        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.INT32:
            raise TypeError("Incompatible type: bitmap_pattern.pass_count was expecting int, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @pass_count.setter
    def pass_count(self, value):        
        """
        Number of passes (scans) to be performed over the pattern area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="PassCount_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.INT32], parameters=[self.__handle, value])
        if isinstance(value, int):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def refresh_time(self) -> 'float':        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.refresh_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @refresh_time.setter
    def refresh_time(self, value):        
        """
        The minimum loop time that must at least elapse before the next pass, so that the adsorbed gas can be refreshed.
        """
        call_request = CallRequest(object_id=self.__id, method_name="RefreshTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def volume_per_dose(self) -> 'float':        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.volume_per_dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @volume_per_dose.setter
    def volume_per_dose(self, value):        
        """
        The volume of material that is removed per charge.
        """
        call_request = CallRequest(object_id=self.__id, method_name="VolumePerDose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def blur(self) -> 'float':        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.blur was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @blur.setter
    def blur(self, value):        
        """
        Like Defocus, but specifying the additional diameter of the blurred spot.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Blur_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def interaction_diameter(self) -> 'float':        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.interaction_diameter was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @interaction_diameter.setter
    def interaction_diameter(self, value):        
        """
        The interaction diameter for an infinitely small beam.
        """
        call_request = CallRequest(object_id=self.__id, method_name="InteractionDiameter_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def enabled(self) -> 'bool':        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: bitmap_pattern.enabled was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @enabled.setter
    def enabled(self, value):        
        """
        If set to False, the pattern is removed from the patterning job.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Enabled_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dose(self) -> 'float':        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.dose was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dose.setter
    def dose(self, value):        
        """
        Defines the charge dose per area.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Dose_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def dwell_time(self) -> 'float':        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.dwell_time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @dwell_time.setter
    def dwell_time(self, value):        
        """
        The time the beam spends on a single pixel per pass (rounded to a multiple of 25 ns).
        """
        call_request = CallRequest(object_id=self.__id, method_name="DwellTime_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def time(self) -> 'float':        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.time was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @time.setter
    def time(self, value):        
        """
        The time required to process the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Time_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_x(self) -> 'float':        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.center_x was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_x.setter
    def center_x(self, value):        
        """
        X coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterX_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def center_y(self) -> 'float':        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.center_y was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @center_y.setter
    def center_y(self, value):        
        """
        Y coordinate of the pattern center position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="CenterY_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def width(self) -> 'float':        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.width was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @width.setter
    def width(self, value):        
        """
        The pattern width.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Width_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def height(self) -> 'float':        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.height was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @height.setter
    def height(self, value):        
        """
        The pattern height.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Height_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def depth(self) -> 'float':        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: bitmap_pattern.depth was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @depth.setter
    def depth(self, value):        
        """
        Depth of the pattern.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Depth_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.DOUBLE], parameters=[self.__handle, value])
        if isinstance(value, (int, float)):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_direction(self) -> 'str':        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: bitmap_pattern.scan_direction was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_direction.setter
    def scan_direction(self, value):        
        """
        Direction of a movement of a scan.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanDirection_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def scan_type(self) -> 'str':        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.STRING:
            raise TypeError("Incompatible type: bitmap_pattern.scan_type was expecting str, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @scan_type.setter
    def scan_type(self, value):        
        """
        Scanning strategy used while patterning.
        """
        call_request = CallRequest(object_id=self.__id, method_name="ScanType_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.STRING], parameters=[self.__handle, value])
        if isinstance(value, str):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def fix_aspect_ratio(self) -> 'bool':        
        """
        When set to true the aspect ratio is fixed, while the false value means width and height may be changed independently.
        """
        call_request = CallRequest(object_id=self.__id, method_name="FixAspectRatio_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: bitmap_pattern.fix_aspect_ratio was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @fix_aspect_ratio.setter
    def fix_aspect_ratio(self, value):        
        """
        When set to true the aspect ratio is fixed, while the false value means width and height may be changed independently.
        """
        call_request = CallRequest(object_id=self.__id, method_name="FixAspectRatio_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "BitmapPattern"), DataType.BOOL], parameters=[self.__handle, value])
        if isinstance(value, bool):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


class GisPort(object):    
    """
    The object represents a single Gas Injection System port.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.GisPort"

    @property
    def _handle(self):
        return self.__handle


    def insert(self):        
        """
        Insert GIS needle if retracted.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Insert", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def retract(self):        
        """
        Retract GIS needle if inserted.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Retract", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def open(self):        
        """
        Opens the GIS port.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Open", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def close(self):        
        """
        Closes the GIS port.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Close", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def turn_heater_on(self):        
        """
        Turn GIS heater on.
        """
        call_request = CallRequest(object_id=self.__id, method_name="TurnHeaterOn", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def turn_heater_off(self):        
        """
        Turn GIS heater off.
        """
        call_request = CallRequest(object_id=self.__id, method_name="TurnHeaterOff", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def get_temperature(self) -> 'float':        
        """
        Get GIS port gas temperature in Kelvins.
        
        :return: Gas temperature.
        :rtype: float
        """
        call_request = CallRequest(object_id=self.__id, method_name="GetTemperature", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "GisPort")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: gis_port.get_temperature was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value


class Multichem(object):    
    """
    The object represents whole MultiChem device.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.Multichem"

    @property
    def _handle(self):
        return self.__handle


    def insert(self, position = UndefinedParameter):        
        """
        Insert MultiChem needle to one of predefined positions.
        
        :param str position: Name of a MultiChem insert position.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Insert", signature=[], parameters=[])
        if position is UndefinedParameter:
            call_request.parameters.data_types = [DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem")]
            call_request.parameters.values = [self.__handle]
            call_response = self.__application_client._perform_call(call_request)
        elif isinstance(position, str):
            call_request.parameters.data_types = [DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem"), DataType.STRING]
            call_request.parameters.values = [self.__handle, position]
            call_response = self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")


    def retract(self):        
        """
        Retract MultiChem needle if inserted.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Retract", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def open(self):        
        """
        Opens the MultiChem.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Open", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def close(self):        
        """
        Closes the MultiChem.
        """
        call_request = CallRequest(object_id=self.__id, method_name="Close", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    def turn_heater_on(self, gas_name):        
        """
        Turn MultiChem heater on for selected gas.
        
        :param str gas_name: Name of the selected gas.
        """
        call_request = CallRequest(object_id=self.__id, method_name="TurnHeaterOn", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem"), DataType.STRING], parameters=[self.__handle, gas_name]) 
        if isinstance(gas_name, str):
            call_response = self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    def turn_heater_off(self, gas_name):        
        """
        Turn MultiChem heater off for selected gas.
        
        :param str gas_name: Name of the selected gas.
        """
        call_request = CallRequest(object_id=self.__id, method_name="TurnHeaterOff", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem"), DataType.STRING], parameters=[self.__handle, gas_name]) 
        if isinstance(gas_name, str):
            call_response = self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    def get_temperature(self, gas_name) -> 'float':        
        """
        Get temperature of selected gas in the MultiChem in Kelvins.
        
        :param str gas_name: Name of the selected gas.
        
        :return: Gas temperature.
        :rtype: float
        """
        call_request = CallRequest(object_id=self.__id, method_name="GetTemperature", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem"), DataType.STRING], parameters=[self.__handle, gas_name]) 
        if isinstance(gas_name, str):
            call_response = self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")
        if call_response.result.data_type != DataType.DOUBLE:
            raise TypeError("Incompatible type: multichem.get_temperature was expecting float, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    def list_all_gases(self) -> 'List[str]':        
        """
        Lists all gases in the MultiChem.
        
        :return: List of gas names.
        :rtype: list
        """
        call_request = CallRequest(object_id=self.__id, method_name="ListAllGases", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "Multichem")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.LIST_PRIMARY_ID, template_argument=DataType.STRING):
            raise TypeError("Incompatible type: multichem.list_all_gases was expecting list, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value


class ControlItem(object):    
    """
    This object represents instrument server ControlItem.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.ControlItem"

    @property
    def _handle(self):
        return self.__handle


    @property
    def is_controllable(self) -> 'bool':
        call_request = CallRequest(object_id=self.__id, method_name="IsControllable_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItem")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: control_item.is_controllable was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def target_value(self) -> 'Variant':
        call_request = CallRequest(object_id=self.__id, method_name="TargetValue_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItem")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Variant"):
            raise TypeError("Incompatible type: control_item.target_value was expecting Variant, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @target_value.setter
    def target_value(self, value):
        value = Variant.create_from(value)
        call_request = CallRequest(object_id=self.__id, method_name="TargetValue_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItem"), DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Variant")], parameters=[self.__handle, value])
        if isinstance(value, Variant):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def actual_value(self) -> 'Variant':
        call_request = CallRequest(object_id=self.__id, method_name="ActualValue_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItem")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Variant"):
            raise TypeError("Incompatible type: control_item.actual_value was expecting Variant, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @actual_value.setter
    def actual_value(self, value):
        value = Variant.create_from(value)
        call_request = CallRequest(object_id=self.__id, method_name="ActualValue_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItem"), DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Variant")], parameters=[self.__handle, value])
        if isinstance(value, Variant):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def logical_limits(self) -> 'Limits':
        call_request = CallRequest(object_id=self.__id, method_name="LogicalLimits_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItem")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Limits"):
            raise TypeError("Incompatible type: control_item.logical_limits was expecting Limits, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value


class ControlItemPair(object):    
    """
    This object represents instrument server ControlItemPair.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.ControlItemPair"

    @property
    def _handle(self):
        return self.__handle


    @property
    def is_controllable(self) -> 'bool':
        call_request = CallRequest(object_id=self.__id, method_name="IsControllable_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItemPair")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: control_item_pair.is_controllable was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def target_value(self) -> 'Point':
        call_request = CallRequest(object_id=self.__id, method_name="TargetValue_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItemPair")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"):
            raise TypeError("Incompatible type: control_item_pair.target_value was expecting Point, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @target_value.setter
    def target_value(self, value):
        value = Point.create_from(value)
        call_request = CallRequest(object_id=self.__id, method_name="TargetValue_SET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItemPair"), DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point")], parameters=[self.__handle, value])
        if isinstance(value, Point):
            self.__application_client._perform_call(call_request)
        else:
            raise Exception("Cannot execute method with the given parameters combination. Read the documentation for details of how to call this method.")

    @property
    def actual_value(self) -> 'Point':
        call_request = CallRequest(object_id=self.__id, method_name="ActualValue_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItemPair")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Point"):
            raise TypeError("Incompatible type: control_item_pair.actual_value was expecting Point, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value

    @property
    def logical_limits(self) -> 'Limits2d':
        call_request = CallRequest(object_id=self.__id, method_name="LogicalLimits_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ControlItemPair")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataTypeDefinition(DataType.STRUCTURE_PRIMARY_ID, secondary_id="Limits2d"):
            raise TypeError("Incompatible type: control_item_pair.logical_limits was expecting Limits2d, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value


class ServerAction(object):    
    """
    This object represents instrument server startable action.
    """

    __slots__ = ["__id", "__application_client", "__handle"]

    def __init__(self, application_client, handle):
        self.__application_client = application_client
        self.__handle = handle
        self.__id = "SdbMicroscope.DynamicObjects.ServerAction"

    @property
    def _handle(self):
        return self.__handle


    def start(self):
        call_request = CallRequest(object_id=self.__id, method_name="Start", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ServerAction")], parameters=[self.__handle]) 
        call_response = self.__application_client._perform_call(call_request)

    @property
    def is_startable(self) -> 'bool':
        call_request = CallRequest(object_id=self.__id, method_name="IsStartable_GET", signature=[DataTypeDefinition(DataType.DYNAMIC_OBJECT_HANDLE_PRIMARY_ID, "ServerAction")], parameters=[self.__handle])
        call_response = self.__application_client._perform_call(call_request)
        if call_response.result.data_type != DataType.BOOL:
            raise TypeError("Incompatible type: server_action.is_startable was expecting bool, but server returned different object type: " + repr(call_response.result.data_type))

        return call_response.result.value
